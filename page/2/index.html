<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SwiftUI核心技术第12章Dark-Mode和Accessibility" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:33:25.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/">SwiftUI核心技术第12章Dark Mode和Accessibility</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第12章：Dark Mode和Accessibility</strong></p>
<p><strong>第1小节：支持暗黑模式</strong></p>
<p>随着用户对于在不同光照条件下使用设备的需求增加，暗黑模式（Dark Mode）成为了现代应用设计不可或缺的一部分。它不仅有助于减少在低光环境下使用设备时的眼睛疲劳，还能为电池续航带来好处，特别是在OLED屏幕上。此外，暗黑模式还能为用户提供一个更为集中和减少分心的视觉环境。</p>
<h3 id="理解暗黑模式"><a href="#理解暗黑模式" class="headerlink" title="理解暗黑模式"></a>理解暗黑模式</h3><ol>
<li><p><strong>色彩转换</strong> - 暗黑模式不仅仅是将背景设置为黑色和文本设置为白色那么简单。它涉及到色彩配色的整体调整，以确保可读性、可访问性和品牌一致性。</p>
</li>
<li><p><strong>图层和深度</strong> - 暗色背景提升了颜色对比，这意味着阴影和高亮可以用来模拟层次感和深度。</p>
</li>
<li><p><strong>用户控制</strong> - 用户应当能够选择在明亮或暗黑模式下使用应用，或让应用跟随系统设置自动切换。</p>
</li>
</ol>
<h3 id="设计指南"><a href="#设计指南" class="headerlink" title="设计指南"></a>设计指南</h3><ol>
<li><p><strong>颜色主题</strong> - 定义一套色彩主题，包括在暗黑模式下使用的色彩。应使用较亮的色调和透明度来增加层次感，同时避免使用纯白色，以减少对比度导致的刺眼感。</p>
</li>
<li><p><strong>组件和控件</strong> - 确保所有UI组件和控件在暗黑模式下都是可见的，并且它们的状态（如激活、禁用）在两种模式下都清晰。</p>
</li>
<li><p><strong>图片和媒体</strong> - 对于暗黑模式，应考虑使用较暗的图片和插图，或者为图片添加蒙版或过滤器，以适应暗背景。</p>
</li>
<li><p><strong>文本对比度</strong> - 文本应当足够对比，以确保在暗背景下的可读性。对于文本阴影和轮廓也应进行调整。</p>
</li>
</ol>
<h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ol>
<li><p><strong>Asset Catalogs</strong> - 在Xcode的Asset Catalogs中，可以为每种颜色定义亮色和暗色两个版本。</p>
</li>
<li><p><strong>CSS支持</strong> - 在Web内容中，可以使用CSS的<code>prefers-color-scheme</code>查询来为网页添加暗黑模式支持。</p>
</li>
<li><p><strong>SwiftUI</strong> - 在SwiftUI中，可以通过<code>.environment(\.colorScheme, .dark)</code>为预览添加暗黑模式的支持。对于动态颜色，可以使用<code>Color</code>结构体内置的暗黑模式适配。</p>
</li>
<li><p><strong>UIKit</strong> - 在UIKit中，可以使用<code>traitCollection.userInterfaceStyle</code>来检查当前的界面风格，并在需要时调整UI元素的样式。</p>
</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><p><strong>测试</strong> - 在两种模式下都对应用进行全面的测试，确保UI元素的可见性和功能的可用性。</p>
</li>
<li><p><strong>用户设置</strong> - 提供设置选项，允许用户根据个人喜好切换模式。</p>
</li>
<li><p><strong>跟随系统</strong> - 默认情况下，应用应当跟随系统的暗黑模式设置，以保持用户体验的一致性。</p>
</li>
<li><p><strong>节能考量</strong> - 利用暗黑模式的节能优势，在OLED屏幕上通过使用更多真正的黑色来减少能耗。</p>
</li>
<li><p><strong>无障碍</strong> - 确保暗黑模</p>
</li>
</ol>
<p>式下的色彩对比满足无障碍标准，以便色弱和视力障碍用户也能舒适使用。</p>
<p>通过以上的设计和技术实现指南，开发者可以为其应用成功地集成暗黑模式，不仅提高了应用的美观性，同时也照顾到了用户的实际使用需求和舒适度。</p>
<p><strong>第2小节：辅助功能的最佳实践</strong></p>
<p>辅助功能（Accessibility）是确保所有用户，包括那些有视力、听力、运动或学习障碍的人，能够有效使用你的应用的关键组成部分。对于应用开发者来说，这不仅仅是一项法律义务或道德责任，更是一种设计上的优秀实践，它能够扩大应用的潜在用户群体，并提升用户体验。</p>
<h3 id="认识辅助功能的范畴"><a href="#认识辅助功能的范畴" class="headerlink" title="认识辅助功能的范畴"></a>认识辅助功能的范畴</h3><ol>
<li><p><strong>多感官接入</strong> - 保证信息的传递不仅限于一种感官，例如，对于视觉信息，提供文本描述或声音解释。</p>
</li>
<li><p><strong>易用性</strong> - 确保应用的操作简单明了，尤其是对于运动障碍用户，考虑到触摸目标的大小和屏幕的可达性。</p>
</li>
<li><p><strong>可见性</strong> - 包含字体大小的调整、高对比度模式以及颜色不是传达重要信息的唯一方式。</p>
</li>
<li><p><strong>认知考虑</strong> - 设计简洁、一致的界面，减少认知负担，特别是为了那些有认知障碍的用户。</p>
</li>
</ol>
<h3 id="设计指南-1"><a href="#设计指南-1" class="headerlink" title="设计指南"></a>设计指南</h3><ol>
<li><p><strong>文本可读性</strong> - 提供文本大小调整的功能，支持系统级别的“辅助功能”设置。</p>
</li>
<li><p><strong>高对比度</strong> - 提供高对比度主题或模式，辅以清晰的字体，帮助视觉障碍用户更好地识别内容。</p>
</li>
<li><p><strong>颜色盲友好</strong> - 设计UI时不要完全依赖颜色来区分元素或传达信息，使用图形符号或标签作为辅助。</p>
</li>
<li><p><strong>标签和说明</strong> - 所有的交互控件都应该有清晰的标签，辅以适当的声音或触觉反馈。</p>
</li>
<li><p><strong>语音控制</strong> - 支持通过语音命令进行控制，为那些无法使用传统输入设备的用户提供便利。</p>
</li>
</ol>
<h3 id="技术实现-1"><a href="#技术实现-1" class="headerlink" title="技术实现"></a>技术实现</h3><ol>
<li><p><strong>VoiceOver&#x2F;Speak Screen</strong> - 确保SwiftUI或UIKit组件正确实现了辅助功能标签和行为，以便VoiceOver能够读取屏幕上的内容。</p>
</li>
<li><p><strong>动态字体大小</strong> - 使用<code>UIFont.preferredFont(forTextStyle:)</code>和SwiftUI中的<code>.font(.system(size:))</code>来响应用户的字体大小设置。</p>
</li>
<li><p><strong>UIAccessibility协议</strong> - 通过实现相关的UIAccessibility协议来自定义非标准UI组件的辅助功能行为。</p>
</li>
<li><p><strong>辅助功能快捷方式</strong> - 通过设置快捷方式让用户能够快速访问常用的辅助功能。</p>
</li>
</ol>
<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><p><strong>持续测试</strong> - 在开发过程中，经常使用辅助功能进行测试，确保所有用户在使用应用时的体验一致。</p>
</li>
<li><p><strong>社群参与</strong> - 与残障社群合作，获取真实的反馈，并根据这些反馈改进产品。</p>
</li>
<li><p><strong>遵循标准</strong> - 遵循WCAG（Web Content Accessibility Guidelines）等国际标准来设计和开发应用。</p>
</li>
<li><p><strong>教育和文档</strong> - 提供有关如何使用应用中辅助功能的文档或视频教程。</p>
</li>
<li><p><strong>UI测试和自动化</strong> - 利用自动化测试框架来验证辅助功能的实现，确保在应用更新后功能依然可用。</p>
</li>
</ol>
<p>通过实施这些最</p>
<p>佳实践，开发者不仅能够提供一个包容性更强的应用体验，同时也能满足日益增长的多样化用户需求，构建起更加广泛的用户基础。</p>
<p><strong>第3小节：动态字体与国际化</strong></p>
<p>设计一个能够轻松适应不同语言和区域设置的用户界面，以及支持动态字体大小调整，是为了确保应用能够覆盖更广泛的用户群体，特别是那些有特定阅读需求的用户。</p>
<h3 id="动态字体的重要性"><a href="#动态字体的重要性" class="headerlink" title="动态字体的重要性"></a>动态字体的重要性</h3><p>动态字体允许用户根据自己的视力需求来调整字体的大小。这对于那些需要辅助设备阅读的用户尤为重要。</p>
<h3 id="实现动态字体"><a href="#实现动态字体" class="headerlink" title="实现动态字体"></a>实现动态字体</h3><ol>
<li><p><strong>使用系统字体尺寸</strong> - 利用系统提供的字体大小，如在SwiftUI中使用<code>.font(.system(size:))</code>。</p>
</li>
<li><p><strong>响应用户设置</strong> - 应用应该能够响应并遵循用户的辅助功能设置，比如“更大字体”选项。</p>
</li>
<li><p><strong>字体可伸缩性</strong> - 保证应用的布局可以适应不同的字体大小而不会破坏界面设计。</p>
</li>
<li><p><strong>自定义字体的辅助功能</strong> - 如果使用自定义字体，确保它们能够与系统的辅助功能设置兼容，如使用<code>UIFontMetrics</code>来调整。</p>
</li>
</ol>
<h3 id="国际化的挑战"><a href="#国际化的挑战" class="headerlink" title="国际化的挑战"></a>国际化的挑战</h3><p>国际化不仅仅是将文本翻译成不同的语言，还需要考虑到文化差异、布局方向（例如从右到左的语言）、日期和时间格式以及货币单位。</p>
<h3 id="实现国际化"><a href="#实现国际化" class="headerlink" title="实现国际化"></a>实现国际化</h3><ol>
<li><p><strong>本地化字符串</strong> - 使用本地化字符串文件（<code>.strings</code>）和键值对来管理应用中的文本。</p>
</li>
<li><p><strong>自适应布局</strong> - 确保UI能够适应不同的文本长度和布局方向。</p>
</li>
<li><p><strong>日期和数字格式</strong> - 使用<code>DateFormatter</code>和<code>NumberFormatter</code>来处理日期和数字的本地化格式。</p>
</li>
<li><p><strong>资源的国际化</strong> - 包括图像等资源的国际化，确保它们在不同文化中同样适用。</p>
</li>
</ol>
<h3 id="最佳实践-2"><a href="#最佳实践-2" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><p><strong>全面测试</strong> - 在不同的语言和辅助功能设置下测试应用，确保所有功能正常工作。</p>
</li>
<li><p><strong>持续的本地化和国际化</strong> - 让本地化和国际化成为开发流程的一部分，不断更新和完善。</p>
</li>
<li><p><strong>伪本地化测试</strong> - 使用伪本地化来测试应用的布局是否能够适应文字长度的变化。</p>
</li>
<li><p><strong>文化敏感性</strong> - 在设计和开发应用时，考虑到不同文化背景下的用户需求和习俗。</p>
</li>
<li><p><strong>动态字体和布局测试</strong> - 使用Xcode中的辅助功能检查器来预览应用在不同字体大小下的表现。</p>
</li>
</ol>
<p>通过实施这些策略，开发者可以确保他们的应用不仅在不同地区和文化中使用无障碍，而且可以为所有用户提供一个更加个性化和易于使用的体验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC12%E7%AB%A0Dark-Mode%E5%92%8CAccessibility/" data-id="cltv9a4xu0020go740fzv62t4" data-title="SwiftUI核心技术第12章Dark Mode和Accessibility" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第11章适配多平台" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:31:14.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/">SwiftUI核心技术第11章适配多平台</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第11章：适配多平台</strong></p>
<p><strong>第1小节：Catalyst：从iOS到macOS</strong></p>
<p>随着Apple推出Project Catalyst，现在开发者可以更加轻松地将iOS应用带到macOS平台。这一技术允许一个单一的代码库运行在iPad和Mac上，极大地简化了多平台支持的开发过程。在这一小节，我们将讨论如何使用Catalyst来适配你的iOS应用到macOS。</p>
<h3 id="Catalyst基础"><a href="#Catalyst基础" class="headerlink" title="Catalyst基础"></a>Catalyst基础</h3><p>Catalyst是Apple提供的一套工具和API，使得开发者可以用几乎同样的代码在Mac上运行iPad应用。这不仅减少了开发和维护成本，同时也保持了用户在iOS和macOS平台间的一致体验。</p>
<h3 id="启用Catalyst"><a href="#启用Catalyst" class="headerlink" title="启用Catalyst"></a>启用Catalyst</h3><p>在Xcode项目中启用Catalyst非常简单。首先打开你的项目设置，在Targets中选择你的iPad应用。然后，在General选项卡中，勾选“Mac”复选框来启用Mac支持。</p>
<h3 id="调整界面和布局"><a href="#调整界面和布局" class="headerlink" title="调整界面和布局"></a>调整界面和布局</h3><p>macOS和iOS在用户界面和交互上有所不同。因此，即使是通过Catalyst运行在Mac上的iOS应用，也需要进行一些调整来优化用户体验。</p>
<ul>
<li><strong>窗口和视图尺寸</strong>：Mac应用通常拥有更大的窗口和可调整的大小，你需要确保你的界面能够灵活地适应不同尺寸。</li>
<li><strong>菜单和快捷键</strong>：Mac用户习惯于使用顶部菜单栏和快捷键来执行操作。通过Catalyst，你可以为你的应用添加Mac风格的菜单和响应键盘快捷键。</li>
<li><strong>交互方式</strong>：Mac应用通常使用鼠标或触控板，而不是触摸屏。你需要考虑这一点来调整你的应用交互方式。</li>
</ul>
<h3 id="优化代码和资源"><a href="#优化代码和资源" class="headerlink" title="优化代码和资源"></a>优化代码和资源</h3><p>为了在Mac上提供最佳体验，你可能需要根据平台调整代码和资源。</p>
<ul>
<li><strong>条件编译</strong>：使用<code>#if targetEnvironment(macCatalyst)</code>来条件性地编译只在Mac上运行的代码。</li>
<li><strong>资源适配</strong>：可能需要提供更高分辨率的图片或者调整用户界面元素来适应Mac的显示器。</li>
</ul>
<h3 id="调试和测试"><a href="#调试和测试" class="headerlink" title="调试和测试"></a>调试和测试</h3><p>在将iOS应用转移到Mac时，详细的调试和测试是必不可少的。你需要确保应用在Mac上的表现同样稳定，并提供流畅的用户体验。</p>
<ul>
<li><strong>在Mac上运行和调试</strong>：就像在iOS设备上一样，在Xcode中选择Mac作为目标设备，运行和调试你的应用。</li>
<li><strong>适配性测试</strong>：对于不同的窗口尺寸和屏幕分辨率进行测试，确保布局和界面元素都能正确显示和响应。</li>
</ul>
<h3 id="发布和分发"><a href="#发布和分发" class="headerlink" title="发布和分发"></a>发布和分发</h3><p>当你的应用通过Catalyst适配完成后，你可以通过Mac App Store将其发布给全球的用户。这一流程类似于iOS应用的发布，但需要注意的是，你可能需要提供额外的营销材料，如屏幕截图和描述，来适应Mac App Store的展示方式。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Catalyst提供了一个强大的桥梁，让开发者能够将iOS应用无缝迁移到Mac平台。这一过程需要细致的界面调整、代码优化以及充分的测试，但最终可以极大地拓宽你的应用市场，并为用户提供跨平台的统一体验。随着技术的发展，Catalyst将继续发展，为开发者和用户带来更多便利。</p>
<p><strong>第2小节：watchOS特有的UI组件</strong></p>
<p>watchOS为Apple Watch提供了一个独特的操作系统平台，它的设计重点在于快速查看信息和简洁交互。由于屏幕尺寸有限，watchOS提供了一些专门的UI组件，以满足特定的用户体验需求。在这一小节，我们将探讨watchOS的一些特有UI组件及其设计和实现。</p>
<h3 id="WKInterfaceController"><a href="#WKInterfaceController" class="headerlink" title="WKInterfaceController"></a>WKInterfaceController</h3><p><code>WKInterfaceController</code>是watchOS app中视图控制器的基类，用于管理界面。与iOS的<code>UIViewController</code>不同，<code>WKInterfaceController</code>更加专注于内容展示和数据流，而非复杂的布局或动画。</p>
<h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>复杂功能（Complications）允许用户在表盘上直接查看来自应用的关键信息。它们需要使用<code>CLKComplicationDataSource</code>协议来提供动态更新的数据。创建Complications需要细心设计图形和文本，以确保信息在极小的空间内清晰可见。</p>
<h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><p>watchOS的通知设计用于迅速传递信息。使用<code>UNUserNotificationCenter</code>，开发者可以设计富媒体通知，甚至允许用户通过交互直接在Apple Watch上回应。</p>
<h3 id="WKInterfaceTable"><a href="#WKInterfaceTable" class="headerlink" title="WKInterfaceTable"></a>WKInterfaceTable</h3><p><code>WKInterfaceTable</code>是watchOS用于显示列表数据的主要UI组件。与iOS的<code>UITableView</code>相比，<code>WKInterfaceTable</code>的设计更简洁，只支持静态单元格。开发者需要预先定义好所有可能的行类型。</p>
<h3 id="Digital-Crown"><a href="#Digital-Crown" class="headerlink" title="Digital Crown"></a>Digital Crown</h3><p>Digital Crown是Apple Watch上的旋钮，允许用户进行精细的滚动和选择操作。通过<code>crownSequencer</code>，开发者可以检测和响应旋钮的旋转，从而提供一个独特的交互方式。</p>
<h3 id="Force-Touch"><a href="#Force-Touch" class="headerlink" title="Force Touch"></a>Force Touch</h3><p>Force Touch允许watchOS检测屏幕上的压力级别。这可以用来显示上下文菜单或额外控件，为用户提供更多的操作选择。使用<code>WKInterfaceDevice</code>的<code>play(_:)</code>方法，还可以给予触觉反馈。</p>
<h3 id="Interface-Objects"><a href="#Interface-Objects" class="headerlink" title="Interface Objects"></a>Interface Objects</h3><p>watchOS提供了一系列预定义的界面对象（如<code>WKInterfaceLabel</code>，<code>WKInterfaceImage</code>等），它们是优化过的，以确保在小屏幕上的最佳显示效果。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局在watchOS中相对简单。所有元素都是垂直或水平排列的，没有自动布局系统。开发者通过设置组（Group）来组织界面，组可以嵌套，以创造更复杂的布局结构。</p>
<h3 id="性能和电池寿命"><a href="#性能和电池寿命" class="headerlink" title="性能和电池寿命"></a>性能和电池寿命</h3><p>由于Apple Watch的硬件限制，性能优化和电池寿命考量至关重要。应用应当避免过多的背景活动，而且要智能地安排网络请求和数据更新。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计watchOS应用时，开发者必须考虑到平台的独特性，包括小屏幕尺寸和有限的交互方式。通过有效利用watchOS提供的特有UI组件，开发者可以创建出既美观又实用的Apple Watch应用。此外，性能和电池寿命的优化也是watchOS应用设计中不可忽视的一部分。通过精心设计和优化，你的应用将能在这个独特的平台上提供强大功能和良好体验。</p>
<p><strong>第3小节：tvOS和大屏体验</strong></p>
<p>tvOS是苹果为Apple TV设计的操作系统，它为大屏幕交互提供了特殊的用户体验和设计挑战。tvOS的应用开发不仅要考虑到大屏幕带来的视觉冲击，还要处理与iOS明显不同的用户输入方式。以下是tvOS应用开发的关键点。</p>
<h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><ol>
<li><p><strong>布局</strong> - 由于电视屏幕通常较大，你需要为元素间的距离和尺寸采取不同的考量。确保文字和图标在沙发观看距离仍然清晰可辨。</p>
</li>
<li><p><strong>焦点驱动的交互</strong> - 在tvOS中，用户通过遥控器的触摸板来控制界面上的焦点。应用需要处理焦点变化，并给予用户清晰的视觉反馈。</p>
</li>
<li><p><strong>全屏体验</strong> - 利用大屏幕的优势，提供全屏背景图像和视频，创造沉浸式体验。</p>
</li>
</ol>
<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><ol>
<li><p><strong>远程控制</strong> - Apple TV Remote的触摸表面提供了基础的轻扫和点击输入，开发者需设计易于用遥控器导航的界面。</p>
</li>
<li><p><strong>游戏控制器</strong> - 对于游戏应用，Apple TV支持MFi游戏控制器，这为复杂交互提供了更多可能。</p>
</li>
<li><p><strong>语音输入</strong> - 利用Siri远程功能，可以为应用添加语音搜索和控制能力。</p>
</li>
</ol>
<h3 id="图像和视频"><a href="#图像和视频" class="headerlink" title="图像和视频"></a>图像和视频</h3><ol>
<li><p><strong>分辨率和图像优化</strong> - Apple TV支持高达4K的分辨率，要求图片和视频内容具有高质量，以适应高分辨率的显示需求。</p>
</li>
<li><p><strong>视频播放</strong> - tvOS对于媒体播放有优化，支持HDR和Dolby Vision。开发者应当使用AVKit来实现视频播放，以确保最佳体验。</p>
</li>
</ol>
<h3 id="数据存储和缓存"><a href="#数据存储和缓存" class="headerlink" title="数据存储和缓存"></a>数据存储和缓存</h3><ol>
<li><p><strong>本地存储限制</strong> - Apple TV对本地数据存储有限制，应用需要通过iCloud或网络来同步和存储大部分数据。</p>
</li>
<li><p><strong>缓存策略</strong> - 为了优化性能和减少加载时间，有效的数据缓存策略是必须的。</p>
</li>
</ol>
<h3 id="性能和流畅性"><a href="#性能和流畅性" class="headerlink" title="性能和流畅性"></a>性能和流畅性</h3><ol>
<li><p><strong>动画和过渡</strong> - 在大屏幕上，动画需要更加平滑和精细，以避免拖影和断续感。</p>
</li>
<li><p><strong>内存管理</strong> - Apple TV的内存资源比移动设备更丰富，但仍然需要高效的内存管理，尤其是在处理高分辨率媒体内容时。</p>
</li>
</ol>
<h3 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h3><ol>
<li><strong>无障碍功能</strong> - 提供声音指导和简化的控制方案，以确保所有用户都能愉快地使用你的应用。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>tvOS应用开发是一个大屏幕交互设计和用户体验的全新领域。与手机和平板不同，它要求开发者从居家观看的角度出发，考虑到用户与屏幕之间的距离、环境亮度等因素，从而设计出易于使用、视觉效果出色的界面。此外，由于输入设备的限制和平台特性，tvOS应用需要特别关注焦点管理和用户输入的响应性。通过在设计上投入更多考虑和精心调优性能，你的应用将能在大屏幕上提供卓越的用户体验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC11%E7%AB%A0%E9%80%82%E9%85%8D%E5%A4%9A%E5%B9%B3%E5%8F%B0/" data-id="cltv9a4xu001ygo744vu993u1" data-title="SwiftUI核心技术第11章适配多平台" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第10章集成Core-Data和CloudKit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:20:39.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/">SwiftUI核心技术第10章集成Core Data和CloudKit</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第10章：集成Core Data和CloudKit</strong></p>
<p><strong>第1小节：Core Data概念和配置</strong></p>
<p>Core Data是Apple提供的一套强大的框架，用于iOS、macOS、watchOS和tvOS应用的数据管理。它提供了对象图管理和持久化支持，使得开发者可以高效地存储和查询数据而无需直接操作数据库。在本小节中，我们将深入了解Core Data的基本概念，并指导如何在SwiftUI应用中进行配置。</p>
<p><strong>Core Data的关键概念</strong></p>
<ol>
<li><p><strong>托管对象模型（Managed Object Model）</strong>：作为Core Data的基础，定义了应用的数据模型。它通常通过Xcode的数据模型编辑器图形化地创建，并保存为.xcdatamodeld文件。</p>
</li>
<li><p><strong>托管对象上下文（Managed Object Context）</strong>：是在应用和数据库之间进行交互的主要接口。它管理应用中的数据对象。</p>
</li>
<li><p><strong>持久化存储协调器（Persistent Store Coordinator）</strong>：负责管理数据的存储。它连接数据模型和数据存储。</p>
</li>
<li><p><strong>托管对象（Managed Object）</strong>：对数据模型中定义的实体（Entity）的实例，它在上下文中被管理。</p>
</li>
<li><p><strong>实体（Entity）</strong>：数据模型中定义的一个数据结构，对应于传统数据库中的表。</p>
</li>
<li><p><strong>属性（Attribute）</strong>：实体中的字段，用来定义存储数据的类型。</p>
</li>
<li><p><strong>关系（Relationship）</strong>：定义实体间的连接，类似于数据库中的外键。</p>
</li>
<li><p><strong>获取请求（Fetch Request）</strong>：用来查询数据模型，返回一个或多个托管对象。</p>
</li>
</ol>
<p><strong>配置Core Data</strong></p>
<p>在SwiftUI中配置Core Data通常遵循以下步骤：</p>
<ol>
<li><p><strong>创建数据模型</strong>：在Xcode中新建一个数据模型文件，并添加必要的实体和属性。</p>
</li>
<li><p><strong>添加Core Data堆栈</strong>：设置托管对象模型、持久化存储协调器和托管对象上下文。在Xcode项目模板中，如果选择了使用Core Data，则大部分配置已由模板自动生成。</p>
</li>
<li><p><strong>初始化Core Data堆栈</strong>：通常在应用启动时进行，例如在<code>AppDelegate</code>或<code>SceneDelegate</code>中。</p>
</li>
<li><p><strong>在SwiftUI视图中使用</strong>：在SwiftUI视图中，通过环境变量<code>@Environment(\.managedObjectContext)</code>访问托管对象上下文。</p>
</li>
</ol>
<p><strong>示例代码：配置Core Data环境</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常在AppDelegate或类似的地方进行初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataController</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> container: <span class="type">NSPersistentContainer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        container <span class="operator">=</span> <span class="type">NSPersistentContainer</span>(name: <span class="string">&quot;Model&quot;</span>)</span><br><span class="line">        container.loadPersistentStores &#123; (storeDescription, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error <span class="keyword">as</span> <span class="type">NSError</span>? &#123;</span><br><span class="line">                <span class="comment">// 实际应用中应处理错误，这里简化了处理</span></span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">&quot;Unresolved error <span class="subst">\(error)</span>, <span class="subst">\(error.userInfo)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SwiftUI视图中使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">var</span> managedObjectContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>DataController</code>负责初始化Core Data堆栈，并加载持久化存储。在SwiftUI视图中，我们通过<code>@Environment</code>属性包装器注入了托管对象上下文，以便在视图中使用。</p>
<p><strong>总结</strong></p>
<p>Core Data是一个强大的框架，它为数据持久化和管理提供了丰富的功能。理解其核心概念并在SwiftUI项目中进行正确配置，是高效使用该框架的关键。随后的小节中，我们将探讨如何使用Core Data进行数据的创建、读取、更新和删除操作，以及如何将Core Data与CloudKit集成，实现数据的云同步。</p>
<p><strong>第2小节：SwiftUI中的Core Data集成</strong></p>
<p>在SwiftUI应用中集成Core Data可以让我们更加便捷地管理模型层数据。这个过程涉及到模型定义、上下文管理和视图更新。在本小节，我们将详细介绍如何在SwiftUI中集成Core Data。</p>
<p><strong>模型定义</strong></p>
<p>模型定义是使用Core Data的第一步。在Xcode的模型编辑器中，您可以定义实体、属性和关系。这些模型元素代表了应用中的数据结构。对于每一个实体，Core Data都能自动生成对应的<code>NSManagedObject</code>子类，您可以直接在代码中使用。</p>
<p><strong>示例代码：定义一个Person实体</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在.xcdatamodeld文件中已经定义了Person实体及其属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>: <span class="title class_">NSManagedObject</span> &#123;</span><br><span class="line">    <span class="keyword">@NSManaged</span> <span class="keyword">public</span> <span class="keyword">var</span> id: <span class="type">UUID</span></span><br><span class="line">    <span class="keyword">@NSManaged</span> <span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">@NSManaged</span> <span class="keyword">public</span> <span class="keyword">var</span> age: <span class="type">Int16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集成到SwiftUI视图</strong></p>
<p>在SwiftUI中，通过<code>@FetchRequest</code>属性包装器可以创建对Core Data实体的查询请求，并将结果直接绑定到用户界面。当底层数据变化时，界面也会自动更新。</p>
<p><strong>示例代码：使用<code>@FetchRequest</code>展示数据</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonListView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.managedObjectContext) <span class="keyword">private</span> <span class="keyword">var</span> viewContext</span><br><span class="line">    <span class="meta">@FetchRequest</span>(</span><br><span class="line">        sortDescriptors: [<span class="type">NSSortDescriptor</span>(keyPath: \<span class="type">Person</span>.name, ascending: <span class="literal">true</span>)],</span><br><span class="line">        animation: .default)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> persons: <span class="type">FetchedResults</span>&lt;<span class="type">Person</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(persons, id: \.id) &#123; person <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(person.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>@FetchRequest</code>初始化了一个请求来获取所有<code>Person</code>对象，并按<code>name</code>属性升序排序。<code>persons</code>数组将自动更新，以反映数据库中的数据。</p>
<p><strong>数据操作</strong></p>
<p>对于Core Data中的数据，您可以使用托管对象上下文（<code>NSManagedObjectContext</code>）进行操作，包括创建新对象、修改属性、保存更改或删除对象。</p>
<p><strong>示例代码：添加新Person对象</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addPerson</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int16</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPerson <span class="operator">=</span> <span class="type">Person</span>(context: viewContext)</span><br><span class="line">    newPerson.id <span class="operator">=</span> <span class="type">UUID</span>()</span><br><span class="line">    newPerson.name <span class="operator">=</span> name</span><br><span class="line">    newPerson.age <span class="operator">=</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> viewContext.save()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// 这里处理错误</span></span><br><span class="line">        <span class="keyword">let</span> nsError <span class="operator">=</span> error <span class="keyword">as</span> <span class="type">NSError</span></span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;Unresolved error <span class="subst">\(nsError)</span>, <span class="subst">\(nsError.userInfo)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SwiftUI中的Context传递</strong></p>
<p>在SwiftUI应用中，托管对象上下文是通过环境传递的。这意味着您可以在应用的顶层视图中设置上下文，并通过环境变量在子视图中访问。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyApp</span>: <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataController <span class="operator">=</span> <span class="type">DataController</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">                .environment(\.managedObjectContext, dataController.container.viewContext)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ContentView</code>或其任何子视图中，您都可以通过<code>@Environment</code>来获取上下文。</p>
<p><strong>总结</strong></p>
<p>SwiftUI与Core Data的集成使得数据管理变得直观和无缝。通过定义数据模型、执行数据操作以及将数据变化反馈到UI，可以构建出响应式的用户界面。确保正确地处理数据操作中的错误，并在需要的地方更新视图。接下来的小节将深入探讨如何优化数据操作，以及如何将Core Data与CloudKit结合使用，实现数据的云同步和共享。</p>
<p><strong>第3小节：使用CloudKit进行数据同步</strong></p>
<p>Core Data与CloudKit的集成为数据提供了一个强大的云同步功能。通过这种集成，用户可以在不同的设备之间无缝同步数据，同时还可以分享数据到其他用户。在本小节中，我们将深入探讨如何设置和使用CloudKit进行数据同步。</p>
<h3 id="CloudKit-概述"><a href="#CloudKit-概述" class="headerlink" title="CloudKit 概述"></a>CloudKit 概述</h3><p>CloudKit是苹果提供的一个后端存储解决方案，它可以让开发者存储数据在iCloud上，实现跨设备的数据同步。与Core Data集成后，CloudKit可以自动处理网络请求、数据缓存以及差异合并等复杂任务。</p>
<h3 id="设置CloudKit"><a href="#设置CloudKit" class="headerlink" title="设置CloudKit"></a>设置CloudKit</h3><p>在Xcode中启用CloudKit非常简单。首先需要在应用的Capabilities选项中打开iCloud，并勾选CloudKit。这样做将为您的应用创建一个iCloud container。</p>
<p>然后，确保您的Core Data模型设置正确。在.xcdatamodeld文件的数据模型编辑器中，选择模型文件，然后在Model Inspector中勾选“Use CloudKit”。</p>
<h3 id="模型和记录类型"><a href="#模型和记录类型" class="headerlink" title="模型和记录类型"></a>模型和记录类型</h3><p>在CloudKit中，每个Core Data实体将映射到一个CloudKit记录类型（CKRecordType）。实体的属性和关系将映射为记录的字段。在设置实体时，需要注意数据类型的兼容性，以确保顺利映射。</p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><h4 id="初始化同步"><a href="#初始化同步" class="headerlink" title="初始化同步"></a>初始化同步</h4><p>使用<code>NSPersistentCloudKitContainer</code>作为您的持久化容器，可以实现Core Data和CloudKit之间的数据同步。在应用启动时，你需要设置持久化容器来初始化CloudKit同步。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreData</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataController</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> container: <span class="type">NSPersistentCloudKitContainer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        container <span class="operator">=</span> <span class="type">NSPersistentCloudKitContainer</span>(name: <span class="string">&quot;Model&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> description <span class="operator">=</span> container.persistentStoreDescriptions.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Persistent store description was not found.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        description.setOption(<span class="literal">true</span> <span class="keyword">as</span> <span class="type">NSNumber</span>, forKey: <span class="type">NSPersistentStoreRemoteChangeNotificationPostOptionKey</span>)</span><br><span class="line">        </span><br><span class="line">        container.loadPersistentStores &#123; storeDescription, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error <span class="keyword">as</span> <span class="type">NSError</span>? &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">&quot;Unresolved error <span class="subst">\(error)</span>, <span class="subst">\(error.userInfo)</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>NSPersistentStoreRemoteChangeNotificationPostOptionKey</code>选项允许您接收到数据变更通知。</p>
<h4 id="监听数据变化"><a href="#监听数据变化" class="headerlink" title="监听数据变化"></a>监听数据变化</h4><p>为了让您的用户界面响应CloudKit的数据变更，您可以监听<code>NSPersistentStoreRemoteChange</code>通知。每当CloudKit中的数据发生变化时，都会发送通知，并且您可以更新UI。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.default.addObserver(</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">    selector: <span class="keyword">#selector</span>(handleDataChangeNotification(<span class="keyword">_</span>:)),</span><br><span class="line">    name: .<span class="type">NSPersistentStoreRemoteChange</span>,</span><br><span class="line">    object: <span class="literal">nil</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">@objc</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleDataChangeNotification</span>(<span class="keyword">_</span> <span class="params">notification</span>: <span class="type">Notification</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理数据变化，更新UI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据冲突和合并"><a href="#数据冲突和合并" class="headerlink" title="数据冲突和合并"></a>数据冲突和合并</h3><p>处理数据冲突是云同步的重要方面。Core Data和CloudKit集成提供了一种自动的冲突解决策略。默认情况下，最后写入的数据将会“赢”，覆盖之前的数据。如果需要，也可以自定义冲突解决策略。</p>
<h3 id="调试和错误处理"><a href="#调试和错误处理" class="headerlink" title="调试和错误处理"></a>调试和错误处理</h3><p>当处理云同步时，调试和错误处理是不可或缺的。您应当仔细检查错误日志，并对可能的同步错误做出反应。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将Core Data与CloudKit集成，为应用添加云同步功能，可以极大地改善用户体验。通过简单的设置和API调用，您可以实现数据在多个设备间的同步，并允许用户之间共享数据。确保在实现过程中，处理好初始化同步、数据变更监听、数据冲突及错误处理等关键环节。在后续小节中，我们将讨论如何利用Cloud</p>
<p>Kit的高级特性来构建更为复杂的云同步方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC10%E7%AB%A0%E9%9B%86%E6%88%90Core-Data%E5%92%8CCloudKit/" data-id="cltv9a4xu001wgo74alsi743k" data-title="SwiftUI核心技术第10章集成Core Data和CloudKit" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第9章复合视图与可复用性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:18:34.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/">SwiftUI核心技术第9章复合视图与可复用性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第9章：复合视图与可复用性</strong></p>
<p><strong>第1小节：组合现有视图</strong></p>
<p>在构建复杂的用户界面时，有效的视图复用和组合是提高代码可维护性和减少重复的关键。SwiftUI以其声明式语法和数据驱动的方法论，为视图的复合提供了极佳的支持。</p>
<p><strong>视图复合的概念</strong></p>
<p>视图复合是指将多个较小的视图组合成一个复杂的视图的过程。这是软件工程中“组合优于继承”原则的直接体现，允许开发者通过构建并组合简单的视图块来创建复杂的用户界面。</p>
<p><strong>基本视图组合</strong></p>
<p>在SwiftUI中，最基本的视图组合可以通过使用Stacks、Groups等容器视图来完成。例如，一个简单的登录表单可以通过组合TextFields和Button视图来创建：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LoginForm</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> password: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;Username&quot;</span>, text: <span class="variable">$username</span>)</span><br><span class="line">                .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">            <span class="type">SecureField</span>(<span class="string">&quot;Password&quot;</span>, text: <span class="variable">$password</span>)</span><br><span class="line">                .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Log In&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// Handle login action</span></span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个自定义的<code>LoginForm</code>视图，它将两个文本字段和一个按钮组合在一起。</p>
<p><strong>视图抽象</strong></p>
<p>SwiftUI的另一个强大功能是能够创建可复用的自定义视图。例如，如果我们发现在不同的地方多次使用相同的文本样式，可以将其抽象为一个可复用的视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TitleText</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(text)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .foregroundColor(.blue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>TitleText</code>视图可以确保文本样式的一致性，并且在更新样式时，只需修改<code>TitleText</code>视图的定义即可。</p>
<p><strong>利用视图修饰符</strong></p>
<p>除了创建完整的自定义视图外，开发者也可以定义视图修饰符来封装常用的修改器组合。这可以进一步简化视图定义并增强可读性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardStyle</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .padding()</span><br><span class="line">            .background(<span class="type">Color</span>.white)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">            .shadow(radius: <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cardStyle</span>() -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">CardStyle</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，任何视图都可以轻松地应用这个“卡片”样式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    .cardStyle()</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>通过组合现有视图，开发者可以在SwiftUI中高效地构建复杂的用户界面。这种方法的核心优势是它提高了代码的可维护性、减少了重复，并且通过自定义视图和视图修饰符，能够轻松实现视图的一致性和可复用性。这种模块化的构建方式非常适合快速迭代和扩展，是构建复杂UI时的推荐方法。</p>
<p><strong>第2小节：创建可复用的视图库</strong></p>
<p>在构建复杂的SwiftUI应用时，开发者会逐渐积累起一组可复用的视图和视图修饰符。将这些元素组织成一个内部视图库，不仅可以提升开发效率，还可以确保UI的一致性。在这一节中，我们将探讨如何创建和维护一个可复用的视图库。</p>
<p><strong>可复用视图库的优点</strong></p>
<ol>
<li><strong>一致性</strong>：统一的视图库可以确保整个应用的视觉元素保持一致。</li>
<li><strong>效率</strong>：通过重用视图组件，可以避免重复劳动，加快开发速度。</li>
<li><strong>可维护性</strong>：需要调整设计时，只需要更新视图库中的组件即可影响整个应用。</li>
</ol>
<p><strong>设计可复用视图</strong></p>
<p>当设计一个可复用视图时，考虑以下几个方面：</p>
<ul>
<li><strong>通用性</strong>：视图应该足够通用，能够适应不同的使用场景。</li>
<li><strong>可配置性</strong>：提供合理的接口来调整视图的外观和行为。</li>
<li><strong>独立性</strong>：视图应该是自包含的，不依赖于外部状态。</li>
</ul>
<p><strong>视图库结构</strong></p>
<p>一个好的视图库应该具有清晰的结构，通常包含以下几个层次：</p>
<ol>
<li><strong>基础视图</strong>：最基本的视图组件，如按钮、标签、输入框等。</li>
<li><strong>视图修饰符</strong>：用于修饰视图的通用样式，如阴影、边框、字体样式等。</li>
<li><strong>复合视图</strong>：由多个基础视图或其他复合视图组合而成的复杂视图。</li>
<li><strong>布局</strong>：用于组织视图在容器中的位置和排列的布局组件。</li>
</ol>
<p><strong>实施示例</strong></p>
<p>让我们来定义一个基础的可复用视图库的组件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrimaryButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> action: () -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: action) &#123;</span><br><span class="line">            <span class="type">Text</span>(title)</span><br><span class="line">                .fontWeight(.bold)</span><br><span class="line">                .frame(minWidth: <span class="number">0</span>, maxWidth: .infinity)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(<span class="type">Color</span>.blue)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .cornerRadius(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图修饰符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ShadowModifier</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .shadow(color: .gray, radius: <span class="number">5</span>, x: <span class="number">0</span>, y: <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">applyShadow</span>() -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        modifier(<span class="type">ShadowModifier</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合视图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserInfoCard</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> email: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(username)</span><br><span class="line">                .font(.headline)</span><br><span class="line">                .applyShadow()</span><br><span class="line">            <span class="type">Text</span>(email)</span><br><span class="line">                .font(.subheadline)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">        .background(<span class="type">Color</span>.white)</span><br><span class="line">        .cornerRadius(<span class="number">10</span>)</span><br><span class="line">        .applyShadow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>视图库的维护</strong></p>
<ul>
<li><strong>文档</strong>：为每个组件编写详细的文档，说明其用法和配置选项。</li>
<li><strong>示例应用</strong>：创建一个示例应用，演示视图库中每个组件的用法。</li>
<li><strong>版本控制</strong>：当更新视图库时，使用版本控制来管理变更。</li>
</ul>
<p><strong>小结</strong></p>
<p>创建和维护一个可复用的视图库是提高SwiftUI应用开发效率和质量的有效方法。通过精心设计和文档化，视图库不仅能够确保UI的一致性，还能极大地简化应用的迭代和扩展。</p>
<p><strong>第3小节：自定义Modifier</strong></p>
<p>在SwiftUI中，<code>Modifier</code>允许开发者封装一系列的视图修改操作，并可复用于不同的视图。通过创建自定义的<code>Modifier</code>，可以极大地提高代码的可维护性和清晰度，同时也使得UI组件的风格和布局保持一致。本小节将详细介绍如何定义和使用自定义Modifier。</p>
<p><strong>理解Modifier</strong></p>
<p>Modifier是一种遵循<code>ViewModifier</code>协议的结构体，它通过改变视图的渲染和布局属性来修改视图的外观和行为。每当对视图应用Modifier时，SwiftUI都会在背后创建一个新的视图结构，而不是修改旧的视图。这使得视图修改操作既安全又易于管理。</p>
<p><strong>创建自定义Modifier</strong></p>
<ol>
<li><strong>定义Modifier结构体</strong>：首先，需要定义一个结构体并遵循<code>ViewModifier</code>协议。</li>
<li><strong>实现<code>body</code>属性</strong>：在结构体中实现必需的<code>body</code>计算属性，它接收一个<code>Content</code>参数，并返回一个新的视图。</li>
<li><strong>添加修改操作</strong>：在<code>body</code>属性中，对传入的<code>Content</code>进行修改，如添加边框、改变字体、设置背景等。</li>
</ol>
<p><strong>示例：自定义圆角和阴影Modifier</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundedShadowModifier</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> shadowRadius: <span class="type">CGFloat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .cornerRadius(radius)</span><br><span class="line">            .shadow(radius: shadowRadius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roundedShadow</span>(<span class="params">radius</span>: <span class="type">CGFloat</span>, <span class="params">shadowRadius</span>: <span class="type">CGFloat</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        modifier(<span class="type">RoundedShadowModifier</span>(radius: radius, shadowRadius: shadowRadius))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为<code>RoundedShadowModifier</code>的自定义Modifier，它将圆角和阴影效果应用于任何视图。通过<code>extension</code>扩展<code>View</code>，我们为所有视图添加了一个名为<code>roundedShadow</code>的新方法，它使得应用圆角和阴影更加便捷。</p>
<p><strong>使用自定义Modifier</strong></p>
<p>一旦定义了自定义Modifier，就可以在任何视图上像使用内置Modifier一样使用它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, SwiftUI!&quot;</span>)</span><br><span class="line">    .roundedShadow(radius: <span class="number">10</span>, shadowRadius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>优化Modifier</strong></p>
<ul>
<li><strong>链式调用</strong>：Modifier可以链式调用，使得视图修改更加灵活。</li>
<li><strong>条件修改</strong>：可以使用条件语句动态地应用Modifier。</li>
<li><strong>性能考虑</strong>：尽量避免创建过于复杂的Modifier，以免影响性能。</li>
</ul>
<p><strong>总结</strong></p>
<p>自定义Modifier在SwiftUI开发中是一项强大的工具，它不仅可以提高代码的复用性和清晰度，还可以帮助维护应用的视觉一致性。通过创建合适的自定义Modifier，可以简化视图的构建过程，并提升开发效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC9%E7%AB%A0%E5%A4%8D%E5%90%88%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7/" data-id="cltv9a4xw002ogo74d76986mg" data-title="SwiftUI核心技术第9章复合视图与可复用性" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第8章动画与转场" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:13:02.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/">SwiftUI核心技术第8章动画与转场</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第8章：动画与转场</strong></p>
<p><strong>第1小节：基础动画</strong></p>
<p>在SwiftUI中，动画是用来增强用户体验的一种手段，它可以提供平滑的视觉过渡和引人注目的交互。通过使用SwiftUI强大的动画API，你可以轻松地为界面元素添加动画效果。</p>
<p><strong>动画的类型</strong></p>
<p>在SwiftUI中，动画主要可以分为隐式动画和显式动画两大类。</p>
<ol>
<li><strong>隐式动画</strong>：最简单的动画形式，仅需要使用<code>.animation()</code>修饰符，并为其提供一个动画样式。</li>
<li><strong>显式动画</strong>：使用<code>withAnimation</code>函数来明确开始动画的时间点，并提供一个动画样式。</li>
</ol>
<p><strong>创建一个简单的隐式动画</strong></p>
<p>你可以通过在视图的某个状态改变时附加<code>.animation()</code>修饰符，让这个状态改变带有动画效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleAnimationView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> scale: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .scaleEffect(scale)</span><br><span class="line">            .animation(.easeInOut, value: scale)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                scale <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每当用户点击圆形，<code>scale</code>状态变量就会增加，而圆形的尺寸变化将以渐进渐出的方式动画显示。</p>
<p><strong>使用<code>withAnimation</code>进行显式动画</strong></p>
<p>如果你想控制动画的触发时机，而不是依赖于状态的改变，你可以使用<code>withAnimation</code>来显式地执行动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Tap Me&quot;</span>) &#123;</span><br><span class="line">    withAnimation(.spring(response: <span class="number">0.5</span>, dampingFraction: <span class="number">0.5</span>, blendDuration: <span class="number">1</span>)) &#123;</span><br><span class="line">        scale <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当按钮被点击时，不管<code>scale</code>的值如何变化，动画都会被执行。</p>
<p><strong>动画的组合</strong></p>
<p>你可以将不同的动画效果组合在一起，创建复杂的动画序列。这通过在<code>.animation()</code>修饰符中使用<code>Animation</code>的静态方法来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.animation(</span><br><span class="line">    <span class="type">Animation</span>.easeInOut(duration: <span class="number">2</span>).repeatForever(autoreverses: <span class="literal">true</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此代码会创建一个无限重复并自动反向的渐进渐出动画。</p>
<p><strong>动画参数</strong></p>
<p>SwiftUI提供了许多可以调整动画行为的参数：</p>
<ul>
<li><code>duration</code>：动画的时长。</li>
<li><code>delay</code>：动画开始前的等待时间。</li>
<li><code>repeatCount</code>：动画重复的次数。</li>
<li><code>autoreverses</code>：动画是否在完成后自动反向。</li>
</ul>
<p><strong>小结</strong></p>
<p>基础动画是SwiftUI中最容易实现的动画类型，它们可以快速为你的应用添加视觉吸引力和反馈。通过使用隐式动画或显式动画，你可以控制动画的触发方式和行为。此外，SwiftUI的动画系统是高度可组合的，允许你通过组合和定制动画参数来创建复杂的动画效果。</p>
<p>在本书的后续章节中，我们将深入探讨如何使用SwiftUI的高级动画功能，比如路径动画、自定义时间曲线以及动画的联动效果，来创建更具表现力和创造力的用户界面。</p>
<p><strong>第2小节：自定义动画</strong></p>
<p>在SwiftUI中，除了内置的动画类型，开发者还可以通过自定义动画来进一步个性化UI交互。自定义动画允许开发者控制动画的具体行为和时间曲线，实现独特的动态效果。</p>
<p><strong>动画时间曲线</strong></p>
<p>时间曲线描述了动画状态值随时间的变化方式。SwiftUI提供了几种内置的时间曲线，例如<code>easeIn</code>、<code>easeOut</code>和<code>easeInOut</code>。要自定义这些曲线，你可以使用<code>timingCurve(_:_:_:_:)</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.animation(.timingCurve(<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">1</span>, duration: <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>

<p>这个方法接受四个表示贝塞尔曲线控制点的参数，可以非常精细地控制动画的加速和减速过程。</p>
<p><strong>使用<code>interpolatingSpring</code>自定义弹簧动画</strong></p>
<p>如果你需要一个物理弹性效果，可以使用<code>interpolatingSpring(stiffness:damping:)</code>函数来自定义一个弹簧动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.animation(.interpolatingSpring(stiffness: <span class="number">50</span>, damping: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>调整<code>stiffness</code>（刚度）和<code>damping</code>（阻尼）参数可以模拟不同的弹簧物理特性。</p>
<p><strong>使用<code>Animation</code>的<code>delay(_: )</code>和<code>speed(_: )</code>自定义动画速度和延迟</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.animation(.easeInOut(duration: <span class="number">2</span>).delay(<span class="number">0.5</span>).speed(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>这里，动画会在半秒延迟后开始，并且以原始时长的两倍速度播放。</p>
<p><strong>自定义动画路径</strong></p>
<p>SwiftUI动画不仅限于简单的开始和结束状态之间的过渡。使用<code>GeometryEffect</code>，你可以创建完全自定义的动画路径。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomAnimationView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimated <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .modifier(<span class="type">CustomPathModifier</span>(isAnimated: <span class="variable">$isAnimated</span>))</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                withAnimation &#123;</span><br><span class="line">                    isAnimated.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomPathModifier</span>: <span class="title class_">GeometryEffect</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isAnimated: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">effectValue</span>(<span class="params">size</span>: <span class="type">CGSize</span>) -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">UIBezierPath</span>()</span><br><span class="line">        path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: isAnimated <span class="operator">?</span> size.height : <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// Your custom path here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: path.currentPoint.x, y: path.currentPoint.y))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过创建一个遵循<code>GeometryEffect</code>协议的自定义修饰符，你可以定义一个复杂的动画路径，这个路径由一个点沿着给定路径移动的动画组成。</p>
<p><strong>自定义动画的应用场景</strong></p>
<ul>
<li>当内置动画不能满足你的设计需求时。</li>
<li>当你想要创建一个与众不同的动态交互体验。</li>
<li>在需要精确控制动画行为，如游戏或特定动画教程中。</li>
</ul>
<p><strong>小结</strong></p>
<p>自定义动画是SwiftUI动画功能的深入使用。通过控制时间曲线、弹簧动画参数和自定义动画路径，你可以创造出个性化和专业级别的动态效果。自定义动画能提升应用的专业感和用户的交互体验，使你的应用在众多相似应用中脱颖而出。</p>
<p>接下来，我们将探讨转场动画，它们可以为视图的呈现和消失提供引人注目的视觉效果。</p>
<p><strong>第3小节：交互式和响应式动画</strong></p>
<p>在构建现代的用户界面时，我们不仅希望动画能够提供视觉上的引导和反馈，还希望它们能够与用户的交互紧密结合，创造流畅的体验。这就是交互式和响应式动画发挥作用的地方。在SwiftUI中，你可以根据用户的输入或其他事件，实时地调整动画，从而创建出高度交互的UI元素。</p>
<p><strong>交互式动画</strong></p>
<p>交互式动画是指随着用户的操作实时变化的动画。例如，拖动滑块时的动态变化或者通过手势控制的动画。</p>
<p><strong>实现交互式动画的方法</strong></p>
<p>你可以通过以下方式为你的应用添加交互式动画：</p>
<ol>
<li><p><strong>使用Gesture</strong></p>
<p>绑定手势到视图，然后在手势变化时更新视图的状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">InteractiveView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@GestureState</span> <span class="keyword">private</span> <span class="keyword">var</span> dragState <span class="operator">=</span> <span class="type">CGSize</span>.zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span>()</span><br><span class="line">            .fill(<span class="type">Color</span>.blue)</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .offset(dragState)</span><br><span class="line">            .gesture(</span><br><span class="line">                <span class="type">DragGesture</span>()</span><br><span class="line">                    .updating(<span class="variable">$dragState</span>) &#123; value, state, <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                        state <span class="operator">=</span> value.translation</span><br><span class="line">                    &#125;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>DragGesture</code>跟踪手指的拖动，并实时更新<code>Rectangle</code>的偏移。</p>
</li>
<li><p><strong>与动画状态链接</strong></p>
<p>将动画和状态变量结合起来，实现随状态改变而动画的效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResponsiveView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> position <span class="operator">=</span> <span class="type">CGPoint</span>.zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .position(position)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                withAnimation &#123;</span><br><span class="line">                    position <span class="operator">=</span> <span class="type">CGPoint</span>(x: position.x <span class="operator">+</span> <span class="number">100</span>, y: position.y <span class="operator">+</span> <span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，每次点击都会使圆形移动，并伴随平滑的过渡动画。</p>
</li>
</ol>
<p><strong>响应式动画</strong></p>
<p>响应式动画则是指根据外部事件或数据的变化而自动触发的动画。例如，当接收到新消息时，提示符以动画的形式出现。</p>
<p><strong>实现响应式动画的方法</strong></p>
<ol>
<li><p><strong>数据绑定</strong></p>
<p>通过观察对象中的<code>@Published</code>属性变化来驱动动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnimationViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoadingView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">AnimationViewModel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line">            .rotationEffect(<span class="type">Angle</span>(degrees: viewModel.isLoading <span class="operator">?</span> <span class="number">360</span> : <span class="number">0</span>))</span><br><span class="line">            .animation(<span class="type">Animation</span>.linear(duration: <span class="number">1</span>).repeatForever(autoreverses: <span class="literal">false</span>), value: viewModel.isLoading)</span><br><span class="line">            .onAppear &#123;</span><br><span class="line">                viewModel.isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>isLoading</code>变为<code>true</code>时，圆形会开始无限旋转，模拟加载指示器的效果。</p>
</li>
<li><p><strong>环境变量</strong></p>
<p>利用<code>@EnvironmentObject</code>或其他环境属性，在多个视图之间共享动画状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> userSettings: <span class="type">UserSettings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(userSettings.username)</span><br><span class="line">            .scaleEffect(userSettings.isLoggedOut <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">            .animation(.spring(), value: userSettings.isLoggedOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户注销时，用户名的文本会通过缩放动画消失。</p>
</li>
</ol>
<p><strong>小结</strong></p>
<p>交互式和响应式动画在提高应用的用户体验方面起着至关重要的作用。在SwiftUI中，你可以轻松地将动画与用户的交互以及应用的数据状态相结合。</p>
<p><strong>第4小节：转场动画</strong></p>
<p>转场动画是用户界面的一部分，它们在视图的呈现和消失时创造连贯的视觉效果。在SwiftUI中，转场是以声明的方式定义的，允许开发者指定添加或删除视图时的动画类型。利用转场，开发者可以提供一种流畅的视觉体验，减少用户界面变化对用户认知的干扰。</p>
<p><strong>基础转场</strong></p>
<p>SwiftUI提供了几种内置的转场类型，例如<code>.opacity</code>、<code>.slide</code>和<code>.scale</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPresented <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isPresented &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">                    .transition(.slide)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Toggle View&quot;</span>) &#123;</span><br><span class="line">                withAnimation &#123;</span><br><span class="line">                    isPresented.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当<code>isPresented</code>状态变化时，<code>Text</code>视图会滑入或滑出。</p>
<p><strong>组合转场</strong></p>
<p>你还可以组合多个转场来创建独特的效果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.transition(.asymmetric(insertion: .scale, removal: .opacity))</span><br></pre></td></tr></table></figure>

<p>在这里，视图出现时使用缩放效果，消失时使用渐隐效果。</p>
<p><strong>自定义转场</strong></p>
<p>SwiftUI还允许创建自定义转场。这通常是通过定义视图的两种状态并描述它们之间的动画过渡来实现的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">AnyTransition</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> pivot: <span class="type">AnyTransition</span> &#123;</span><br><span class="line">        .modifier(</span><br><span class="line">            active: <span class="type">CornerRotateModifier</span>(amount: <span class="operator">-</span><span class="number">90</span>),</span><br><span class="line">            identity: <span class="type">CornerRotateModifier</span>(amount: <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CornerRotateModifier</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> amount: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content.rotationEffect(<span class="type">Angle</span>(degrees: amount), anchor: .topLeading)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个自定义转场中，<code>pivot</code>通过旋转视图的顶部锚点实现转动效果。</p>
<p><strong>使用转场动画</strong></p>
<p>转场可以与<code>withAnimation</code>闭包结合使用，来实现视图状态变化时的平滑过渡。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Toggle View&quot;</span>) &#123;</span><br><span class="line">    withAnimation(.spring()) &#123;</span><br><span class="line">        isPresented.toggle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将创建一个在点击按钮时视图呈现和消失时有弹簧动效的交互。</p>
<p><strong>小结</strong></p>
<p>转场动画在SwiftUI中为开发者提供了一个高效的方法来处理视图的呈现和消失，使用户界面更加生动和有趣。内置的转场类型适用于多数情况，而自定义转场则为特殊需求提供了无限的可能性。通过恰当使用转场，可以大大提升应用的质感和用户满意度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC8%E7%AB%A0%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BD%AC%E5%9C%BA/" data-id="cltv9a4xw002igo7413rgcfrd" data-title="SwiftUI核心技术第8章动画与转场" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第7章导航与呈现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T01:09:18.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/">SwiftUI核心技术第7章导航与呈现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第7章：导航与呈现</strong></p>
<p><strong>1. NavigationView和NavigationViewLink</strong></p>
<p>在SwiftUI中，<code>NavigationView</code>和<code>NavigationLink</code>组合起来使用，提供了一个强大的导航框架，让我们可以构建具有层次结构的页面间跳转。它们的设计遵循了SwiftUI的声明式语法，使得页面跳转和数据传递变得直观和易于管理。</p>
<p><strong>NavigationView</strong></p>
<p><code>NavigationView</code>是一个容器视图，它承载着你的视图层次结构，并提供了展示这些视图的空间。你可以把它看作是页面导航的起点。通常，一个<code>NavigationView</code>包含一个或多个<code>View</code>，这些<code>View</code>可以通过<code>NavigationLink</code>来进行跳转。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">List</span>(selection: <span class="variable">$selectedItem</span>) &#123;</span><br><span class="line">        <span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(item: item)) &#123;</span><br><span class="line">            <span class="type">Text</span>(item.title)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .navigationBarTitle(<span class="type">Text</span>(<span class="string">&quot;Items&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>NavigationView</code>包含了一个列表，列表中的每一项都绑定了一个<code>NavigationLink</code>，点击时将展示<code>DetailView</code>。</p>
<p><strong>NavigationLink</strong></p>
<p><code>NavigationLink</code>负责在<code>NavigationView</code>中触发页面跳转。它有多个初始化方法，可以根据需求选择使用。最基本的用法是提供一个目标视图和触发跳转的内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(item: item)) &#123;</span><br><span class="line">    <span class="type">Text</span>(item.title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>NavigationLink</code>的目的地是<code>DetailView</code>，用户点击列表项上的<code>Text</code>时会触发导航到<code>DetailView</code>。</p>
<p><strong>激活和反激活链接</strong></p>
<p><code>NavigationLink</code>可以与SwiftUI的状态绑定，以编程方式激活或反激活导航。通过在<code>NavigationLink</code>初始化时传递一个布尔型的绑定，你可以控制导航的行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isLinkActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(), isActive: <span class="variable">$isLinkActive</span>) &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Go to Details&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">self</span>.isLinkActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，一个按钮被用来激活<code>NavigationLink</code>。当用户点击按钮，<code>isLinkActive</code>状态变为<code>true</code>，触发导航到<code>DetailView</code>。</p>
<p><strong>传递数据</strong></p>
<p>在导航过程中，你可能需要向目的地视图传递数据。<code>NavigationLink</code>的<code>destination</code>参数让你可以轻松做到这一点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(item: item)) &#123;</span><br><span class="line">    <span class="type">ItemRow</span>(item: item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，每个<code>ItemRow</code>是一个列表中的行，它带有一个与之关联的<code>item</code>数据模型。点击<code>ItemRow</code>时，<code>item</code>将被传递到<code>DetailView</code>。</p>
<p><strong>小结</strong></p>
<p><code>NavigationView</code>和<code>NavigationLink</code>构成了SwiftUI中页面导航的基石。它们的使用方式灵活而强大，支持各种复杂的导航模式。通过声明式语法，我们可以更专注于视图的内容和业务逻辑，而不是导航的细节。本章节的后续部分将探讨更高级的导航模式，如使用<code>TabView</code>和<code>modal</code>呈现，以及如何处理数据传递和状态管理。</p>
<p><strong>2. TabView</strong></p>
<p>在构建一个用户界面时，底部的标签栏是一种常见的设计，允许用户轻松切换不同的视图或功能模块。在SwiftUI中，这可以通过<code>TabView</code>来实现。<code>TabView</code>为应用提供了一个选项卡式的界面，每个选项卡都代表了一个视图。</p>
<p><strong>基本用法</strong></p>
<p><code>TabView</code>的基本用法涉及到声明式地列出每一个选项卡，并使用<code>tabItem</code>修饰符来定义每个标签的外观，通常包括图标和文本。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line">        .tabItem &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;house&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Home&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;设置&quot;</span>)</span><br><span class="line">        .tabItem &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;gear&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Settings&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中，<code>TabView</code>包含了两个选项卡：“首页”和“设置”，每个选项卡都是用<code>Text</code>视图表示的，并且有对应的系统图标。</p>
<p><strong>选项卡状态管理</strong></p>
<p><code>TabView</code>可以与<code>@State</code>变量绑定，从而允许你编程方式控制当前激活的选项卡。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedTab <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">TabView</span>(selection: <span class="variable">$selectedTab</span>) &#123;</span><br><span class="line">        <span class="type">HomeView</span>()</span><br><span class="line">            .tabItem &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;house&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Home&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .tag(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">SettingsView</span>()</span><br><span class="line">            .tabItem &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;gear&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Settings&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .tag(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>selectedTab</code>绑定到<code>TabView</code>的<code>selection</code>参数。通过改变<code>selectedTab</code>的值，你可以改变当前选中的标签页。</p>
<p><strong>自定义外观</strong></p>
<p><code>TabView</code>的外观可以通过多种方式进行自定义。例如，可以使用<code>.accentColor</code>来改变选中标签的颜色。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="comment">// ... 你的选项卡</span></span><br><span class="line">&#125;</span><br><span class="line">.accentColor(.green)</span><br></pre></td></tr></table></figure>

<p><strong>结合NavigationView使用</strong></p>
<p>在<code>TabView</code>内部，你可能还会嵌入<code>NavigationView</code>，以在选项卡内部提供导航堆栈。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TabView</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">HomeView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    .tabItem &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: <span class="string">&quot;house&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Home&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他选项卡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做可以确保每个选项卡都能拥有独立的导航历史，这对于用户体验非常重要。</p>
<p><strong>使用场景</strong></p>
<p><code>TabView</code>在很多类型的应用中都非常有用。它是构建具有多个独立部分的应用的理想选择，例如社交网络应用、具有个人中心、消息、设置等的应用。</p>
<p><strong>小结</strong></p>
<p>通过本节的介绍，我们了解了如何使用<code>TabView</code>创建具有多个交互式选项卡的界面。<code>TabView</code>不仅提供了高度的可定制性，还能够很好地与其他视图和数据流模式协同工作。在接下来的小节中，我们将继续探索更多关于SwiftUI中视图呈现和数据流管理的先进概念。</p>
<p><strong>3. Sheets和Alerts</strong></p>
<p>在构建应用时，弹出视图和警告框（Alerts）是与用户交互的重要方式。在SwiftUI中，这通常通过使用<code>Sheet</code>和<code>Alert</code>视图完成。</p>
<p><strong>Sheets</strong></p>
<p>Sheet是一种覆盖在当前内容上的卡片样式视图，通常用于导航流程之外的辅助任务，比如表单填写、设置选项等。</p>
<p><strong>创建Sheet</strong></p>
<p>要创建一个Sheet，你需要使用<code>.sheet</code>修饰符，并为其提供一个绑定的布尔值，这个布尔值决定Sheet是否可见。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingSheet <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Show Sheet&quot;</span>) &#123;</span><br><span class="line">        showingSheet.toggle()</span><br><span class="line">    &#125;</span><br><span class="line">    .sheet(isPresented: <span class="variable">$showingSheet</span>) &#123;</span><br><span class="line">        <span class="comment">// Sheet的内容</span></span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Here&#x27;s the Sheet&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义Sheet</strong></p>
<p>Sheet的内容可以是任意视图。例如，你可以创建一个包含表单的<code>NavigationView</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.sheet(isPresented: <span class="variable">$showingSheet</span>) &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">Form</span> &#123;</span><br><span class="line">            <span class="comment">// 表单内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        .navigationBarTitle(<span class="string">&quot;Settings&quot;</span>, displayMode: .inline)</span><br><span class="line">        .navigationBarItems(trailing: <span class="type">Button</span>(<span class="string">&quot;Done&quot;</span>) &#123;</span><br><span class="line">            showingSheet <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Sheet实现细节</strong></p>
<p>在内部，Sheet会自动管理自己的显示和隐藏。你可以将<code>showingSheet</code>绑定到视图的某个状态或者对象的属性上，当这个属性变化时，对应的Sheet会自动显示或隐藏。</p>
<p><strong>Alerts</strong></p>
<p>Alerts用于显示重要信息，并可以提供一个或多个操作选项。</p>
<p><strong>创建Alert</strong></p>
<p>和Sheet类似，Alert也使用绑定的布尔值来控制显示状态。不过，创建Alert时，通常还会指定标题、消息和按钮。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingAlert <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Show Alert&quot;</span>) &#123;</span><br><span class="line">        showingAlert <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    .alert(isPresented: <span class="variable">$showingAlert</span>) &#123;</span><br><span class="line">        <span class="type">Alert</span>(</span><br><span class="line">            title: <span class="type">Text</span>(<span class="string">&quot;Warning&quot;</span>),</span><br><span class="line">            message: <span class="type">Text</span>(<span class="string">&quot;Are you sure?&quot;</span>),</span><br><span class="line">            primaryButton: .destructive(<span class="type">Text</span>(<span class="string">&quot;Delete&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 删除操作</span></span><br><span class="line">            &#125;,</span><br><span class="line">            secondaryButton: .cancel()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Alert的样式</strong></p>
<p>Alert可以有多种样式，从简单的带有单一按钮的Alert到复杂的带有多个按钮和自定义操作的Alert。</p>
<p><strong>小结</strong></p>
<p>Sheet和Alert都是在SwiftUI中管理临时视图和用户交互的重要工具。通过合理使用这两种视图，你可以创建出既直观又有效的用户体验。正如我们所见，SwiftUI提供的<code>.sheet</code>和<code>.alert</code>修饰符让这两种视图的展示和管理变得十分简单。在接下来的章节中，我们将深入探讨如何利用SwiftUI的高级特性来构建更为复杂的用户交互界面。</p>
<p><strong>4. Navigation的高级用法</strong></p>
<p>SwiftUI的导航系统提供了一种直观且声明式的方法来处理视图间的转换。除了基础的<code>NavigationView</code>和<code>NavigationLink</code>之外，我们还可以采用更高级的用法来增强用户体验和视图的灵活性。</p>
<p><strong>程序化导航</strong></p>
<p>在某些情况下，你可能需要从视图模型或响应某个事件时进行导航。这可以通过绑定到视图模型中的属性并使用<code>NavigationLink</code>的<code>isActive</code>参数实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isDetailViewActive <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">ViewModel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(), isActive: <span class="variable">$viewModel</span>.isDetailViewActive) &#123; </span><br><span class="line">                <span class="type">EmptyView</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Go to Details&quot;</span>) &#123;</span><br><span class="line">                viewModel.isDetailViewActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐藏和显示导航栏</strong></p>
<p>在用户界面中，有时候我们需要隐藏导航栏来提供沉浸式体验，或者我们需要在特定的视图中改变导航栏的显示方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DetailView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 隐藏导航栏</span></span><br><span class="line">        .navigationBarHidden(<span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 在视图即将出现时设置导航栏样式</span></span><br><span class="line">        .onAppear &#123;</span><br><span class="line">            <span class="comment">// 设置导航栏样式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义后退按钮行为</strong></p>
<p>有时默认的后退按钮行为并不符合我们的需要。在SwiftUI中，我们可以通过添加一个自定义的按钮并绑定其行为来覆盖默认的后退按钮。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomBackButtonView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.presentationMode) <span class="keyword">var</span> presentationMode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="comment">// 执行自定义后退操作</span></span><br><span class="line">            presentationMode.wrappedValue.dismiss()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;arrow.left&quot;</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Back&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深度链接</strong></p>
<p>深度链接是指直接导航到应用内部的某个特定页面的链接。在SwiftUI中，我们可以监听来自URL的深度链接，并根据链接的内容导航到相应的视图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.onOpenURL &#123; url <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 解析URL并进行导航</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌套导航</strong></p>
<p>在构建复杂的界面时，我们可能会需要嵌套多个<code>NavigationView</code>。虽然这在用户界面上并不常见，但在特定的设计中可能是必要的。嵌套导航需要细心处理，以确保导航栈的正确和流畅的用户体验。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="comment">// 主界面</span></span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="comment">// 嵌套的子界面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>通过上述高级导航功能，开发者可以在SwiftUI中创建复杂且具有出色用户体验的导航流。这些高级技巧的掌握可以帮助你更好地管理视图层级和导航逻辑，让应用的导航更加直观和响应用户操作。在后续章节中，我们将探索如何将这些高级导航技巧与应用的其它部分相结合，以构建完整且功能丰富的应用程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC7%E7%AB%A0%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%91%88%E7%8E%B0/" data-id="cltv9a4xv002ggo74bl3oa17q" data-title="SwiftUI核心技术第7章导航与呈现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第6章数据流与绑定" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T00:52:43.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/">SwiftUI核心技术第6章数据流与绑定</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第6章：数据流与绑定</strong></p>
<p><strong>1. State和Binding</strong></p>
<p>在SwiftUI中，数据流的管理是构建动态和响应式用户界面的核心。<code>State</code>和<code>Binding</code>是实现这种数据流动的基本工具，它们使得数据和视图能够保持同步。</p>
<p><strong>State：拥有数据的真相</strong></p>
<p><code>@State</code> 是一个属性包装器，用于声明SwiftUI管理的状态。这个状态是私有的，仅在当前视图内部使用。当状态变化时，SwiftUI会自动重新绘制依赖于这个状态的视图部分。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isToggled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$isToggled</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>isToggled</code> 是一个布尔状态，与一个开关绑定。当用户切换开关时，<code>isToggled</code> 的值会改变，触发视图的更新。</p>
<p><strong>Binding：连接状态和视图</strong></p>
<p><code>Binding</code> 提供了对某个状态的读写权限，但不拥有这个状态本身。通过<code>$</code>符号，我们可以从一个<code>@State</code>变量创建一个<code>Binding</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ToggleView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isOn: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$isOn</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ToggleView</code> 需要一个<code>Binding</code>来控制开关的状态，这个<code>Binding</code>可以从父视图的<code>@State</code>中派生而来。</p>
<p><strong>使用State和Binding</strong></p>
<p>在实际的应用中，<code>@State</code>适用于简单的局部状态管理，如界面的某个开关、文本输入框的内容等。当状态改变时，只有使用到该状态的视图会重新渲染，从而优化了性能。</p>
<p><code>@Binding</code>则用于将状态的控制权从一个视图传递到另一个视图。例如，在一个父视图中定义了<code>@State</code>，那么就可以将这个状态以<code>Binding</code>的形式传递给子视图，让子视图能够读取并修改这个状态。</p>
<p><strong>State和视图的生命周期</strong></p>
<p>理解<code>@State</code>与视图的生命周期是紧密相关的也很重要。当一个视图被SwiftUI重新绘制时，<code>@State</code>所持有的状态会被保留下来。这意味着状态的变更是持久的，即使视图的某些其他部分可能因为不同的原因而重新渲染。</p>
<p><strong>总结</strong></p>
<p><code>State</code>和<code>Binding</code>是SwiftUI中数据流的基础。<code>@State</code>用于创建可变的状态，当状态变化时，视图会响应这些变化。而<code>Binding</code>则用于在视图之间共享状态，允许多个视图共同拥有和修改状态。通过恰当地使用这两个工具，我们可以创建出既简洁又高效的响应式用户界面。在接下来的章节中，我们将深入探讨如何在更复杂的应用架构中管理状态和数据流。</p>
<p><strong>2. ObservedObject和EnvironmentObject</strong></p>
<p>在构建复杂的SwiftUI应用时，我们经常需要处理跨多个视图共享的数据。在这种情况下，仅使用<code>@State</code>和<code>@Binding</code>可能不够用，因为它们主要用于单个视图或其直接子视图的状态管理。这时，<code>@ObservedObject</code>和<code>@EnvironmentObject</code>就成为了重要的工具。</p>
<p><strong>ObservedObject：动态数据的监听者</strong></p>
<p><code>@ObservedObject</code>用于绑定外部的可观察对象（通常是遵循<code>ObservableObject</code>协议的类实例），当可观察对象发出变化通知时，视图会重新渲染以反映新的数据。</p>
<p>这里有一个<code>ObservableObject</code>的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserData</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;用户&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Published</code>属性包装器用于标记会发生变化的数据。一旦<code>username</code>的值发生变更，就会自动通知所有的观察者。</p>
<p>在视图中使用<code>@ObservedObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UserView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> userData: <span class="type">UserData</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;用户名: <span class="subst">\(userData.username)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>UserView</code>中，<code>userData</code>作为一个<code>@ObservedObject</code>提供了对<code>UserData</code>实例的引用。当<code>username</code>更新时，<code>UserView</code>也会更新其显示。</p>
<p><strong>EnvironmentObject：跨层级的数据共享</strong></p>
<p><code>@EnvironmentObject</code>是一种特殊类型的数据流工具，它可以让数据在视图层级间传递而不需要显式地通过参数传递。它非常适合那些被多个视图访问的全局数据或设置。</p>
<p>首先，你需要在某个父视图中将数据对象添加到环境中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyApp</span>: <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>()</span><br><span class="line">                .environmentObject(<span class="type">UserData</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在子视图中，你可以直接通过<code>@EnvironmentObject</code>来访问这个数据对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProfileView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> userData: <span class="type">UserData</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;欢迎, <span class="subst">\(userData.username)</span>!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要显式地从父视图传递<code>UserData</code>到<code>ProfileView</code>，<code>ProfileView</code>可以直接从环境中获取这个对象。</p>
<p><strong>总结</strong></p>
<p><code>@ObservedObject</code>和<code>@EnvironmentObject</code>为我们提供了强大的数据管理能力，使得数据在视图之间传递变得简单且高效。它们都依赖于<code>ObservableObject</code>协议来观察数据模型的变化并响应更新。<code>@ObservedObject</code>适用于需要直接引用的情况，而<code>@EnvironmentObject</code>更适合于全局或共享数据的情况，尤其是在视图层级较深时。</p>
<p>在接下来的内容中，我们将探讨这些数据流工具如何与SwiftUI的声明式UI框架协同工作，以及如何利用它们来构建响应式和可维护的应用架构。</p>
<p><strong>3. @Published和Combine</strong></p>
<p>在SwiftUI中，数据的流动和管理是构建应用的核心。为了实现响应式的数据流，SwiftUI密切结合了Combine框架。Combine是一个响应式编程框架，它可以处理所有类型的异步事件。<code>@Published</code>是Combine框架中的一个关键特性，它用于创建可观察的对象属性，当这些属性的值发生变化时，它会自动通知系统。</p>
<p><strong>使用@Published</strong></p>
<p>使用<code>@Published</code>可以很容易地将一个类属性变成响应式的属性。这意味着，当属性的值改变时，所有订阅了这个属性的订阅者都会接收到通知，并且可以响应这些变化。</p>
<p>下面是一个使用<code>@Published</code>的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProfileViewModel</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ProfileViewModel</code>是一个遵循<code>ObservableObject</code>协议的类，它有两个<code>@Published</code>属性：<code>name</code>和<code>age</code>。当这些属性中的任何一个的值改变时，所有的观察者都会得到通知。</p>
<p><strong>整合Combine</strong></p>
<p>Combine框架的强大之处在于它可以让你定义复杂的数据处理和变换流程。例如，你可以对输入进行校验、过滤、转换，然后将处理后的数据传递到UI或其他部分。</p>
<p>这里是如何使用Combine订阅<code>@Published</code>属性变化的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cancellables <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> profileVM <span class="operator">=</span> <span class="type">ProfileViewModel</span>()</span><br><span class="line">profileVM.<span class="variable">$name</span></span><br><span class="line">    .sink &#123; name <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Name is now <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .store(in: <span class="operator">&amp;</span>cancellables)</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>$name</code>是对<code>name</code>属性的Publisher访问。<code>.sink</code>方法会接收一个闭包，这个闭包会在每次<code>name</code>属性更新时被调用。<code>.store(in:)</code>方法用于管理订阅生命周期，防止早期释放。</p>
<p><strong>结合SwiftUI视图</strong></p>
<p>在SwiftUI中，你通常不需要直接处理订阅，因为SwiftUI视图可以直接使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>来绑定到可观察的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProfileView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ProfileViewModel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TextField</span>(<span class="string">&quot;Name&quot;</span>, text: <span class="variable">$viewModel</span>.name)</span><br><span class="line">        <span class="type">TextField</span>(<span class="string">&quot;Age&quot;</span>, value: <span class="variable">$viewModel</span>.age, formatter: <span class="type">NumberFormatter</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ProfileView</code>中，每当<code>viewModel</code>的<code>name</code>或<code>age</code>属性变化时，视图会自动更新。</p>
<p><strong>小结</strong></p>
<p><code>@Published</code>与Combine框架结合使用，为SwiftUI应用带来了强大的响应式编程能力。这种模式不仅使状态管理变得简洁，还能够创建可维护和可扩展的数据流处理逻辑。随着你深入本书，你将会看到更多关于Combine在实际SwiftUI应用中的强大用例和模式。</p>
<p><strong>4. 数据流的最佳实践</strong></p>
<p>在构建SwiftUI应用时，高效和可维护的数据流管理是非常重要的。为了达到这个目标，我们需要遵循一些最佳实践来确保我们的应用结构清晰，数据流动合理。以下是在使用SwiftUI时应考虑的数据流最佳实践。</p>
<p><strong>一、明确数据源的单一真相</strong></p>
<p>在任何给定的时刻，应用的每个数据点都应该有一个清晰的，可信的来源。这意味着对于任何可变的数据，都应该有一个单一的可信源，而所有视图的状态应反映这个来源。使用<code>@State</code>的私有属性用于视图的内部状态，而模型对象中的<code>@Published</code>属性用于应用范围的状态。</p>
<p><strong>二、使用单向数据流</strong></p>
<p>在SwiftUI中，数据应该从父视图流向子视图（单向数据流）。父视图传递数据到子视图，子视图通过事件传递回父视图，而不是直接修改父视图的状态。这样可以避免复杂的数据依赖和潜在的循环更新问题。</p>
<p><strong>三、合理使用@State，@Binding，@ObservedObject，和@EnvironmentObject</strong></p>
<ul>
<li><strong>@State</strong> 应当用于视图的局部状态管理，不应跨越多个视图。</li>
<li><strong>@Binding</strong> 允许子视图与父视图的状态或模型中的数据进行通信。</li>
<li><strong>@ObservedObject</strong> 用于当视图需要响应外部模型对象变化时。</li>
<li><strong>@EnvironmentObject</strong> 适用于多个视图需要访问同一共享数据对象的情况。</li>
</ul>
<p><strong>四、谨慎管理生命周期</strong></p>
<p>识别并管理数据对象的生命周期，尤其是当使用<code>@ObservedObject</code>或<code>@EnvironmentObject</code>时。避免不必要的重新创建对象，以减少内存使用和性能损耗。</p>
<p><strong>五、精细控制数据变更</strong></p>
<p>使用<code>objectWillChange</code>手动发送变更通知可以精细控制观察的对象何时更新UI。当需要优化性能或处理复杂的数据变更时这非常有用。</p>
<p><strong>六、利用Combine进行复杂的数据操作</strong></p>
<p>Combine框架提供了一套完整的工具，用于处理复杂的数据转换和异步操作。应充分利用这些工具来实现复杂的数据流和事件处理。</p>
<p><strong>七、避免内存泄漏</strong></p>
<p>当处理数据流和绑定时，确保正确管理订阅，使用<code>AnyCancellable</code>存储返回的订阅，并在不需要时取消订阅，以避免内存泄漏。</p>
<p><strong>八、编写可测试的代码</strong></p>
<p>将数据处理逻辑抽象到可单独测试的模型和服务中。避免将业务逻辑放入视图中，这样可以让代码更容易被测试和维护。</p>
<p><strong>小结</strong></p>
<p>遵循上述的数据流最佳实践将有助于您构建出高效、稳定且易于维护的SwiftUI应用。确保理解和正确应用每一种属性装饰器和Combine操作符是至关重要的。本书后续章节将会进一步深入这些概念，并结合实例演示如何在真实世界的应用中实践这些最佳实践。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC6%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%BB%91%E5%AE%9A/" data-id="cltv9a4xv002ago74a4afenoi" data-title="SwiftUI核心技术第6章数据流与绑定" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第5章布局管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-11-08T00:47:49.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/">SwiftUI核心技术第5章布局管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第5章：布局管理</strong></p>
<p><strong>1. 堆（Stacks）</strong></p>
<p>在SwiftUI中，布局是通过组合不同的视图和使用布局容器来实现的，其中最基础和最常用的布局容器是堆（Stack）。Stacks在SwiftUI中主要有三种类型：<code>HStack</code>、<code>VStack</code>和<code>ZStack</code>，它们分别代表水平堆、垂直堆和覆盖堆。通过这三种Stack，可以构建出复杂的布局结构。</p>
<p><strong>理解堆的工作方式</strong></p>
<ul>
<li><code>HStack</code>（水平堆）将其子视图沿着水平轴排列。</li>
<li><code>VStack</code>（垂直堆）将子视图沿着垂直轴排列。</li>
<li><code>ZStack</code>（覆盖堆）则将子视图按照代码中的顺序覆盖排列，即先声明的视图会被后声明的视图覆盖。</li>
</ul>
<p><strong>使用HStack和VStack管理布局</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;左侧&quot;</span>)</span><br><span class="line">        <span class="type">Spacer</span>() <span class="comment">// Spacer会推动旁边的视图尽可能远的距离</span></span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;右侧&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;第二行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.padding() <span class="comment">// 对VStack添加内边距</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码示例中，我们首先创建了一个<code>VStack</code>，其子视图之间有10点的间距，并且它们在水平方向上左对齐。在这个垂直堆中，我们有两行文本和一个<code>HStack</code>。在<code>HStack</code>中，两个文本视图被一个<code>Spacer</code>隔开，这会推动这些文本视图到<code>HStack</code>的两侧。</p>
<p><strong>ZStack的层叠效果</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZStack</span> &#123;</span><br><span class="line">    <span class="type">Image</span>(<span class="string">&quot;background&quot;</span>)</span><br><span class="line">        .resizable()</span><br><span class="line">        .aspectRatio(contentMode: .fill)</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;层叠的顶部文本&quot;</span>)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.frame(height: <span class="number">300</span>) <span class="comment">// 设置ZStack的高度</span></span><br><span class="line">.clipped() <span class="comment">// 保证图片不会超出ZStack的边界</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ZStack</code>用于创建层叠效果。它首先放置了一张背景图片，然后在图片上层放置了一个<code>VStack</code>，其中包含了一行文本。</p>
<p><strong>使用堆的布局行为</strong></p>
<ul>
<li><code>Stacks</code>默认会尽可能地占据父视图提供的空间，除非使用<code>frame</code>、<code>edgesIgnoringSafeArea</code>、<code>fixedSize</code>等修饰符进行限制。</li>
<li><code>alignment</code>参数控制子视图在交叉轴上的对齐方式（对于<code>HStack</code>是垂直对齐，对于<code>VStack</code>是水平对齐）。</li>
<li><code>spacing</code>参数决定子视图之间的间距。</li>
</ul>
<p><strong>对齐和分布</strong></p>
<p>Stacks的另一个关键特性是对齐。开发者可以非常细致地控制如何对齐子视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;顶部对齐&quot;</span>)</span><br><span class="line">    <span class="type">Divider</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;还是顶部对齐&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个<code>HStack</code>中，所有的子视图都会在顶部对齐，即使它们的高度不同。</p>
<p><strong>总结</strong></p>
<p>通过理解和利用Stacks，你可以构建出直观且灵活的布局。Stacks的简单性和强大的组合能力，使得它们成为SwiftUI布局的核心工具。它们可以嵌套使用，也可以与其他布局视图和控件配合，以创建出复杂且响应式的用户界面。随着你</p>
<p>对这些基础布局工具的熟悉和运用，你将能够更加精准地操控空间，为你的应用提供坚实的视觉基础。</p>
<p><strong>2. 对齐与帧（Alignment and Frames）</strong></p>
<p>布局的精髓在于如何控制视图的大小和位置。在SwiftUI中，<code>对齐</code>和<code>帧</code>是两个基本但强大的概念，它们定义了视图在父视图中的具体摆放方式。</p>
<p><strong>理解对齐</strong></p>
<p>对齐在SwiftUI中是通过对齐指南来实现的，它定义了视图如何根据父视图或兄弟视图的对齐线来定位自己。例如，在一个<code>VStack</code>中，你可以通过<code>alignment</code>参数设置子视图在水平方向上的对齐方式，而在<code>HStack</code>中，这会影响子视图在垂直方向上的对齐。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>(alignment: .bottom) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;底部对齐&quot;</span>)</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;star&quot;</span>)</span><br><span class="line">        .alignmentGuide(.bottom) &#123; d <span class="keyword">in</span> d[.top] &#125;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;这个星星将对齐顶部&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们通过<code>.alignmentGuide</code>修饰符来改变图像视图的默认对齐行为，使其按照顶部对齐而不是底部。</p>
<p><strong>使用帧控制视图大小</strong></p>
<p>帧（frame）允许你为视图设置一个明确的大小或者提供一个理想的大小范围。<code>frame</code>修饰符可以指定宽度（<code>width</code>）、高度（<code>height</code>）、最小宽度（<code>minWidth</code>）、最大宽度（<code>maxWidth</code>）、最小高度（<code>minHeight</code>）、和最大高度（<code>maxHeight</code>）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;固定大小的文本框&quot;</span>)</span><br><span class="line">    .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">    .border(<span class="type">Color</span>.red)</span><br></pre></td></tr></table></figure>

<p>上述代码将文本框的宽度和高度都固定在了100点，无论内容大小如何，文本框都不会改变尺寸。</p>
<p><strong>对齐和帧的组合使用</strong></p>
<p>对齐和帧可以组合使用，以创建更复杂的布局效果。例如，你可能想要创建一个宽度固定，但高度根据内容动态调整的文本视图，同时在其内部文本垂直居中对齐。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;垂直居中的文本&quot;</span>)</span><br><span class="line">    .frame(minHeight: <span class="number">0</span>, maxHeight: .infinity)</span><br><span class="line">    .frame(width: <span class="number">200</span>)</span><br><span class="line">    .background(<span class="type">Color</span>.gray)</span><br><span class="line">    .alignmentGuide(.vertical) &#123; d <span class="keyword">in</span></span><br><span class="line">        d[<span class="type">VerticalAlignment</span>.center]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了两个<code>frame</code>修饰符：第一个<code>frame</code>确保文本在垂直方向上可以扩展到可用的全部空间，第二个<code>frame</code>则设置了文本的固定宽度。通过<code>alignmentGuide</code>，文本在其框架内垂直居中。</p>
<p><strong>总结</strong></p>
<p>对齐和帧是布局时的两个非常重要的概念。通过精确的对齐控制，你可以确保界面元素以一种一致和预期的方式排列。同时，使用帧可以限制和指定视图的大小，无论是固定的还是灵活的。掌握了这些工具，你将能够设计出外观精确且布局合理的界面，即便是面对各种屏幕尺寸和设备方向，你的应用界面也能保持其应有的布局和结构。</p>
<p><strong>3. Spacer和Divider</strong></p>
<p>在构建用户界面时，除了直接操纵视图的尺寸和对齐，SwiftUI还提供了用于控制视图间隔的工具：Spacer和Divider。这些工具在进行视图布局时是不可或缺的，它们可以帮助我们创建出更为优雅和灵活的用户界面。</p>
<p><strong>Spacer: 创建灵活的空间</strong></p>
<p>Spacer是一个会尽可能占用多余空间的视图。在一个Stack中，Spacer可以推动相邻的视图，使其与Stack的边缘或其他视图保持距离。Spacer本身没有可见的内容，但它可以控制布局的间距。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;左边&quot;</span>)</span><br><span class="line">    <span class="type">Spacer</span>() <span class="comment">// 占据所有可用空间</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;右边&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，Spacer位于两个文本视图之间，并推动它们分别靠近水平Stack的左右边缘。</p>
<p>Spacer的另一个常用场景是在其前后添加修饰符，以控制其最小空间尺寸。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;左边&quot;</span>)</span><br><span class="line">    <span class="type">Spacer</span>()</span><br><span class="line">        .frame(minWidth: <span class="number">20</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;右边&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，Spacer至少会创建20点的空间，即使在更大的容器中，它也会扩展以填满额外的空间。</p>
<p><strong>Divider: 分隔视图</strong></p>
<p>Divider是一个用于分隔内容的细线，通常在视觉上表示不同部分的内容。它可以在列表、VStack或HStack中作为清晰分界线使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;第一部分&quot;</span>)</span><br><span class="line">    <span class="type">Divider</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;第二部分&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Divider会自动采用垂直或水平方向，取决于它所在的Stack类型。在VStack中，它是水平的；而在HStack中，则是垂直的。</p>
<p><strong>自定义Spacer和Divider</strong></p>
<p>虽然Spacer和Divider是很好的布局工具，但有时你可能需要更多的自定义。例如，你可以使用背景和框架修饰符来自定义Divider的样式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Divider</span>()</span><br><span class="line">    .background(<span class="type">Color</span>.blue)</span><br><span class="line">    .frame(height: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们自定义了Divider的颜色和高度，创建了一个蓝色的分隔线。</p>
<p>同样，你也可以对Spacer进行类似的自定义。</p>
<p><strong>总结</strong></p>
<p>Spacer和Divider是在SwiftUI中创建和维护视图间隙的简单而强大的工具。它们支持布局的灵活性，同时为内容的视觉分隔提供方便。在理解了如何利用Spacer来控制视图的扩展和收缩，以及如何使用Divider来清晰地区分内容之后，你将能够创建出既美观又实用的布局设计。</p>
<p><strong>4. 布局优先级</strong></p>
<p>当我们在SwiftUI中构建复杂的界面时，经常会遇到多个视图争抢空间的情况。布局优先级（Layout Priority）是一个高级的概念，它允许我们微调视图如何在父视图中分配额外的空间。理解并正确使用布局优先级，可以帮助我们创建更加精确和高度定制的用户界面。</p>
<p><strong>基本概念</strong></p>
<p>在SwiftUI中，所有视图默认具有相同的布局优先级，值为0。当空间不足以满足所有子视图的理想尺寸时，系统会根据布局优先级来决定哪个视图可以首先满足其尺寸需求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;非常非常长的文本&quot;</span>).layoutPriority(<span class="number">1</span>)</span><br><span class="line">    <span class="type">Spacer</span>()</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;短文本&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一个<code>Text</code>视图的布局优先级被设置为1，这意味着它在空间分配时会被优先考虑。即使在有限的空间中，它也会尽可能地显示完整的内容，而<code>Spacer</code>和第二个<code>Text</code>视图会相应地压缩。</p>
<p><strong>布局优先级的使用</strong></p>
<p>布局优先级的值可以是任意的正浮点数。数值越大，获取额外空间的优先级就越高。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;需要更多空间的文本&quot;</span>).layoutPriority(<span class="number">2</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;不那么重要的文本&quot;</span>).layoutPriority(<span class="number">1</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;普通文本&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，第一个文本视图被赋予了最高的优先级（2），其次是第二个文本视图（1），最后是没有显式设置优先级的文本视图（默认为0）。因此，当空间有限时，第一个文本视图会尽量显示更多的内容。</p>
<p><strong>布局优先级的策略</strong></p>
<p>布局优先级通常用于解决视图间的竞争关系，但是它并不是解决所有布局问题的万能钥匙。合理使用布局优先级需要策略，过度依赖可能会导致布局变得难以预测和管理。在设置优先级时，你应当始终考虑内容的重要性以及用户体验。</p>
<p>一个良好的策略是尽量保持简单，只在确实需要时调整布局优先级。并且，始终牢记布局的整体目标是创造既满足设计需求又对用户友好的界面。</p>
<p><strong>结合其他布局工具</strong></p>
<p>布局优先级并不孤立工作，它应该与其他布局工具一起使用，例如<code>frame</code>、<code>alignment</code>、<code>Spacer</code>等。在实际开发中，你会发现布局优先级是与其他布局概念协同工作的，比如使用<code>fixedSize</code>来防止视图被压缩，或者与<code>flexible</code>结合来调整视图的压缩和扩展行为。</p>
<p><strong>总结</strong></p>
<p>掌握了布局优先级的概念和使用方法后，我们就能更加精细地控制SwiftUI布局的行为。正确的布局优先级设置能够确保重要的内容得到展示，辅助视图适应剩余空间，从而创造出既直观又富有层次的用户界面。在设计复杂的布局时，优先级的细微调整可以带来显著的视觉和体验改善。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC5%E7%AB%A0%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/" data-id="cltv9a4xv002ego74b1mpfx75" data-title="SwiftUI核心技术第5章布局管理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术4章视图与控件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2023-11-07T16:35:47.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/">SwiftUI核心技术4章视图与控件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>第二部分：构建用户界面</strong></p>
<p><strong>第4章：视图与控件</strong></p>
<p><strong>1. Text和Image</strong></p>
<p>在SwiftUI中，用户界面是由各种视图组成的，其中最基本的两种视图是<code>Text</code>和<code>Image</code>。本节将详细探讨如何使用这两种视图来显示文本和图像。</p>
<p><strong>Text</strong></p>
<p><code>Text</code>视图用于在应用中显示一行或多行只读文本。它是最常见的视图之一，因为文本是用户交互的基本元素。</p>
<p><strong>基础用法</strong></p>
<p>创建一个<code>Text</code>视图非常简单，只需要传入一个字符串即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello, SwiftUI!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>样式定制</strong></p>
<p><code>Text</code>视图提供了多种修饰符来定制文本的显示方式：</p>
<ul>
<li><code>.font(_:)</code>：设置字体样式。</li>
<li><code>.fontWeight(_:)</code>：设置字体的粗细。</li>
<li><code>.foregroundColor(_:)</code>：设置文本颜色。</li>
<li><code>.lineLimit(_:)</code>：设置最多显示行数。</li>
<li><code>.multilineTextAlignment(_:)</code>：设置多行文本的对齐方式。</li>
<li><code>.padding(_:)</code>：为文本周围添加填充。</li>
</ul>
<p>例如，要创建一个居中对齐、蓝色、加粗的文本，您可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Welcome to SwiftUI&quot;</span>)</span><br><span class="line">    .font(.headline)</span><br><span class="line">    .fontWeight(.bold)</span><br><span class="line">    .foregroundColor(.blue)</span><br><span class="line">    .multilineTextAlignment(.center)</span><br><span class="line">    .padding()</span><br></pre></td></tr></table></figure>

<p><strong>国际化和本地化</strong></p>
<p>SwiftUI还支持文本的国际化和本地化。使用<code>LocalizedStringKey</code>初始化<code>Text</code>视图，可以确保文本根据用户的设备语言环境显示正确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="type">LocalizedStringKey</span>(<span class="string">&quot;hello_message&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>Image</strong></p>
<p><code>Image</code>视图用于在应用中显示图像。您可以从应用的资产目录、文件系统或网络加载图像。</p>
<p><strong>从资产目录加载</strong></p>
<p>最常用的加载图像方式是从Xcode项目的Assets.xcassets目录：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;myImage&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>图像修饰符</strong></p>
<p><code>Image</code>视图也可以使用多种修饰符来调整显示的图像：</p>
<ul>
<li><code>.resizable()</code>：允许图像根据视图的大小进行拉伸或压缩。</li>
<li><code>.aspectRatio(_:_:)</code>：设置图像的宽高比。</li>
<li><code>.clipShape(_:)</code>：剪切图像到特定的形状。</li>
<li><code>.shadow(_:)</code>：为图像添加阴影。</li>
</ul>
<p>例如，要创建一个圆形、有阴影的图像，您可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span>(<span class="string">&quot;profile_pic&quot;</span>)</span><br><span class="line">    .resizable()</span><br><span class="line">    .aspectRatio(contentMode: .fill)</span><br><span class="line">    .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">    .clipShape(<span class="type">Circle</span>())</span><br><span class="line">    .shadow(radius: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>加载和显示网络图像</strong></p>
<p>要显示来自网络的图像，您通常需要使用SwiftUI的<code>AsyncImage</code>视图或结合URLSession自定义一个加载器。由于本节重点是<code>Image</code>视图，我们将在后续章节详细探讨如何加载网络图像。</p>
<p><strong>总结</strong></p>
<p><code>Text</code>和<code>Image</code>是构建SwiftUI应用界面时最基础的元素。它们不仅用法简单，而且通过修饰符提供了强大的样式定制能力。通过合理使用这两种视图，您可以快速构建出丰富多彩且吸引人的界面。接下来的小节，我们将进一步探索SwiftUI中其他重要的视图和控件。</p>
<p><strong>2. Buttons和Toggle</strong></p>
<p>在SwiftUI中，<code>Button</code>和<code>Toggle</code>是两种用于用户交互的基本控件。它们使应用可以响应用户的操作，执行任务或更改状态。</p>
<p><strong>Button</strong></p>
<p>按钮是用户界面的基本组件，用于响应用户的点击或触摸操作。</p>
<p><strong>创建按钮</strong></p>
<p>在SwiftUI中，创建一个按钮需要提供一个动作和一个如何显示的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">    <span class="comment">// 在这里执行按钮的动作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;按钮被点击&quot;</span>)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="comment">// 提供按钮的内容</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;点击我&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按钮样式</strong></p>
<p>您可以使用修饰符来定制按钮的样式。例如，给按钮添加边框、背景色等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;点击我&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;按钮被点击&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.frame(width: <span class="number">200</span>, height: <span class="number">60</span>)</span><br><span class="line">.background(<span class="type">Color</span>.blue)</span><br><span class="line">.foregroundColor(.white)</span><br><span class="line">.cornerRadius(<span class="number">10</span>)</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<p>SwiftUI还提供了<code>buttonStyle(_:)</code>修饰符来应用预定义的按钮样式。</p>
<p><strong>Toggle</strong></p>
<p><code>Toggle</code>是一个开关控件，用于表示和改变一个布尔值的状态。</p>
<p><strong>创建Toggle</strong></p>
<p>创建一个<code>Toggle</code>同样需要一个绑定的状态和一个显示的标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Toggle</span>(isOn: <span class="variable">$isOn</span>) &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;切换状态&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>isOn</code>是一个<code>@State</code>属性，这意味着它是一个可变状态，当<code>Toggle</code>被切换时，视图会自动更新。</p>
<p><strong>定制Toggle</strong></p>
<p>可以使用<code>.toggleStyle(_:)</code>修饰符来定制<code>Toggle</code>的外观。SwiftUI提供了一些内建的样式，如<code>SwitchToggleStyle</code>和<code>CheckboxToggleStyle</code>（后者在macOS上可用）。</p>
<p><strong>绑定和控制</strong></p>
<p>按钮和开关的强大之处在于它们与SwiftUI的数据绑定系统的整合。当您使用<code>$</code>前缀创建绑定时，UI 控件将能够直接修改数据，反之亦然。这是SwiftUI声明式编程范式的核心。</p>
<p><strong>响应用户输入</strong></p>
<p>通常，按钮和开关会更改应用的状态或触发某个操作。例如，您可能会根据开关的状态显示或隐藏文本视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAccepted <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: <span class="variable">$isAccepted</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;接受条款和条件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;继续&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 可以在这里校验开关状态，例如是否接受了条款和条件</span></span><br><span class="line">            proceedWithAction()</span><br><span class="line">        &#125;</span><br><span class="line">        .disabled(<span class="operator">!</span>isAccepted) <span class="comment">// 当不接受条款时禁用按钮</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>按钮和开关是任何交互式应用程序的基础，它们提供了一种简单有效的方式来收集用户输入并作出反应。SwiftUI的<code>Button</code>和<code>Toggle</code>视图配合数据绑定，使得创建动态和响应式的用户界面变得异常简单。它们的样式和行为可以通过一系列的修饰符进行定制，以适应您的设计需求。在接下来的小节中，我们将继续探讨如何使用SwiftUI构建更复杂的用户界面元素。</p>
<p><strong>3. TextField和Slider</strong></p>
<p>在SwiftUI中，创建交互式表单和控制元素是构建现代应用程序不可或缺的一部分。<code>TextField</code>和<code>Slider</code>是两种常用的控件，它们允许用户输入文本和选择值的范围。</p>
<p><strong>TextField</strong></p>
<p><code>TextField</code>是一个用于用户输入文本的控件，它可以接受键盘输入，并且可以对输入的文本进行格式化和校验。</p>
<p><strong>创建TextField</strong></p>
<p>创建一个<code>TextField</code>通常需要两个参数：一个标签和一个绑定到文本值的变量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">TextField</span>(<span class="string">&quot;用户名&quot;</span>, text: <span class="variable">$username</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，每当用户在文本字段中输入时，<code>username</code>变量都会更新。<code>@State</code>属性包装器用于在本地视图状态中存储可变数据。</p>
<p><strong>定制TextField</strong></p>
<p>您可以使用修饰符来定制<code>TextField</code>的外观和行为，例如设置字体、颜色、对齐方式、键盘类型等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span>(<span class="string">&quot;用户名&quot;</span>, text: <span class="variable">$username</span>)</span><br><span class="line">    .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">    .padding()</span><br><span class="line">    .keyboardType(.default)</span><br><span class="line">    .autocapitalization(.none)</span><br><span class="line">    .disableAutocorrection(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了<code>textFieldStyle(_:)</code>来为文本字段设置圆角边框样式，并进行了一些其他的配置。</p>
<p><strong>Slider</strong></p>
<p><code>Slider</code>允许用户从一个范围内选择一个值。它可以用于设置音量、选择亮度或应用任何其他需要用户选择一个数值的场景。</p>
<p><strong>创建Slider</strong></p>
<p>创建<code>Slider</code>至少需要一个绑定到数值的变量和一个值的范围。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> sliderValue: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Slider</span>(value: <span class="variable">$sliderValue</span>, in: <span class="number">0</span><span class="operator">...</span><span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>Slider</code>允许用户在0到1之间选择一个值。</p>
<p><strong>定制Slider</strong></p>
<p><code>Slider</code>同样可以使用修饰符进行外观和功能的定制。您可以设置步长，决定滑块在变化时是否持续触发更新，以及添加标签。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Slider</span>(</span><br><span class="line">    value: <span class="variable">$sliderValue</span>,</span><br><span class="line">    in: <span class="number">0</span><span class="operator">...</span><span class="number">1</span>,</span><br><span class="line">    step: <span class="number">0.1</span>,</span><br><span class="line">    onEditingChanged: &#123; editing <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// editing 是一个布尔值，表示是否正在编辑</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前滑块的值：<span class="subst">\(sliderValue)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">.accentColor(.green)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，滑块的步长设置为0.1，且我们还指定了一个闭包，在用户编辑滑块值时触发。</p>
<p><strong>总结</strong></p>
<p><code>TextField</code>和<code>Slider</code>为SwiftUI应用提供了基本的用户输入功能。通过与<code>@State</code>或其他形式的状态管理相结合，它们为开发者提供了创建动态和响应式表单的能力。定制这些控件的外观和行为使它们能够匹配应用程序的设计语言，提供更好的用户体验。在接下来的章节中，我们将探索SwiftUI中的其他高级控件和视图，并学习如何将它们组合在一起以构建复杂和功能丰富的用户界面。</p>
<p><strong>4. 自定义视图和控件</strong></p>
<p>SwiftUI的真正魅力之一在于它为开发者提供了丰富的自定义视图和控件的能力。通过结合现有的视图和控件以及Swift语言的强大特性，我们可以创建完全定制的用户界面元素，以完美地适应我们的设计需求。</p>
<p><strong>理解视图的组合</strong></p>
<p>在SwiftUI中，最基本的自定义视图起始于现有的视图的组合。SwiftUI的视图是可组合的，意味着你可以将简单的视图组合成复杂的视图。比如，我们可以创建一个带有文本和图像的自定义按钮视图：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;star.fill&quot;</span>)</span><br><span class="line">                .resizable()</span><br><span class="line">                .frame(width: <span class="number">20</span>, height: <span class="number">20</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;收藏&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">        .background(<span class="type">Color</span>.blue)</span><br><span class="line">        .foregroundColor(.white)</span><br><span class="line">        .cornerRadius(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>CustomButton</code>就是一个自定义视图，它可以在任何其他的SwiftUI视图中使用。</p>
<p><strong>创建完全自定义的视图</strong></p>
<p>如果需要更高级的自定义，你可以从<code>View</code>协议开始，实现自己的<code>body</code>属性。这允许你控制视图的渲染方式，并响应用户的输入。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CircularProgressView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> progress: <span class="type">Double</span> <span class="comment">// 从0.0到1.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .stroke(lineWidth: <span class="number">20</span>)</span><br><span class="line">                .opacity(<span class="number">0.3</span>)</span><br><span class="line">                .foregroundColor(<span class="type">Color</span>.blue)</span><br><span class="line">            </span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .trim(from: <span class="number">0.0</span>, to: <span class="type">CGFloat</span>(<span class="built_in">min</span>(<span class="keyword">self</span>.progress, <span class="number">1.0</span>)))</span><br><span class="line">                .stroke(style: <span class="type">StrokeStyle</span>(lineWidth: <span class="number">20</span>, lineCap: .round, lineJoin: .round))</span><br><span class="line">                .foregroundColor(<span class="type">Color</span>.blue)</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>(degrees: <span class="number">270.0</span>))</span><br><span class="line">                .animation(.linear)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个显示进度的环形视图，它会根据<code>progress</code>属性显示不同的填充量。</p>
<p><strong>响应用户交互</strong></p>
<p>自定义视图可以通过各种手势识别器来响应用户的交互。例如，你可能会有一个自定义滑块控件，它通过拖动来改变值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSlider</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> value: <span class="type">Double</span> <span class="comment">// 绑定到外部状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="type">Rectangle</span>()</span><br><span class="line">                .foregroundColor(.gray)</span><br><span class="line">                .frame(height: <span class="number">20</span>)</span><br><span class="line">                .gesture(</span><br><span class="line">                    <span class="type">DragGesture</span>(minimumDistance: <span class="number">0</span>)</span><br><span class="line">                        .onChanged &#123; gesture <span class="keyword">in</span></span><br><span class="line">                            <span class="keyword">self</span>.value <span class="operator">=</span> <span class="type">Double</span>(gesture.location.x <span class="operator">/</span> geometry.size.width)</span><br><span class="line">                        &#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用<code>GeometryReader</code>来获取视图的大小，并根据用户拖动的位置来更新<code>value</code>。</p>
<p><strong>保持性能</strong></p>
<p>在创建自定义视图和控件时，要记住保持它们的性能。这意味着：</p>
<ul>
<li>避免不必要的视图重绘和状态更新。</li>
<li>合理使用<code>.animation()</code>和<code>.transition()</code>修饰符来为视图变化提供流畅的过渡效果。</li>
<li>当视图层次变得复杂时，考虑使用<code>drawingGroup()</code>或<code>cache</code>等优化技术。</li>
</ul>
<p><strong>总结</strong></p>
<p>SwiftUI提供了强大的工具集，可以帮助开发者创建精美且功能丰富的自定义视图和控件。通过结合视图的组合、自定义绘制、响应用户输入等技术，你可以创建出完全符合你的设计和功能需求的用户界面元素。记住，自定义视图和控件不仅仅是关于创造外观，更重要的是它们提供了</p>
<p>与用户交互的新方式。随着你的SwiftUI技能的提高，你将能够更有效地利用这些工具，打造出既美观又高效的应用程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF4%E7%AB%A0%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E4%BB%B6/" data-id="cltv9a4xt001ugo747jtjbmzg" data-title="SwiftUI核心技术4章视图与控件" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SwiftUI核心技术第3章环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC3%E7%AB%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2023-11-07T16:28:17.000Z" itemprop="datePublished">2023-11-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SwiftUI/">SwiftUI</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC3%E7%AB%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">SwiftUI核心技术第3章环境搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>1. Xcode和SwiftUI</strong></p>
<p>为了开始使用SwiftUI，您需要安装Xcode，这是Apple提供的官方集成开发环境（IDE）。Xcode提供了构建iOS、iPadOS、macOS、watchOS和tvOS应用的所有工具和资源。SwiftUI是Xcode的一部分，是一个用于设计和开发用户界面的框架。在这一节中，我们将指导您如何设置Xcode和开始使用SwiftUI。</p>
<p><strong>安装Xcode</strong></p>
<ol>
<li><p><strong>从Mac App Store下载Xcode</strong></p>
<p>Xcode是免费的，可以直接从Mac App Store下载。确保您的Mac操作系统是最新的，因为新版本的Xcode通常只能在最新或次新的操作系统上运行。</p>
</li>
<li><p><strong>启动Xcode并安装额外组件</strong></p>
<p>当您第一次打开Xcode时，它可能会提示您安装额外的必需组件。按照提示进行安装。</p>
</li>
<li><p><strong>接受Xcode许可协议</strong></p>
<p>在安装组件之前，您可能需要接受Xcode的许可协议。您可以通过Xcode或使用终端命令行来完成这一步骤。</p>
</li>
</ol>
<p><strong>配置Xcode</strong></p>
<p>安装完成后，您可能需要进行一些基础配置：</p>
<ol>
<li><p><strong>设置开发者账户</strong></p>
<p>在Xcode的Preferences（偏好设置）中，您可以登录您的Apple开发者账户。如果您还没有账户，您需要注册一个。</p>
</li>
<li><p><strong>下载模拟器或配置开发设备</strong></p>
<p>如果您打算在真实设备上运行应用，需要在Xcode中配置您的iOS设备。否则，您可以下载并使用模拟器。</p>
</li>
</ol>
<p><strong>创建SwiftUI项目</strong></p>
<ol>
<li><p><strong>打开Xcode并创建一个新的项目</strong></p>
<p>选择“Create a new Xcode project”（创建一个新的Xcode项目）。</p>
</li>
<li><p><strong>选择项目模板</strong></p>
<p>在模板选择器中，选择“App”作为您的项目模板。</p>
</li>
<li><p><strong>配置项目设置</strong></p>
<p>您需要填写项目名称、团队、组织名称、组织标识符以及选择您想要支持的平台。</p>
</li>
<li><p><strong>选择SwiftUI作为界面</strong></p>
<p>在创建项目时，确保在“User Interface”选项中选择“SwiftUI”。</p>
</li>
</ol>
<p><strong>探索SwiftUI</strong></p>
<ol>
<li><p><strong>Canvas</strong></p>
<p>Xcode提供了一个实时预览界面（Canvas），您可以看到SwiftUI代码的实时渲染结果。通过点击Canvas右上角的“Resume”按钮，可以启动或刷新预览。</p>
</li>
<li><p><strong>Inspector</strong></p>
<p>Xcode的Inspector可以帮助您调整SwiftUI视图的属性，您可以直接通过图形界面来调整代码，而不需要编写任何代码。</p>
</li>
<li><p><strong>代码编辑器</strong></p>
<p>Xcode的代码编辑器是您编写Swift和SwiftUI代码的地方。它提供了代码高亮、自动完成等功能，这可以极大提升编码效率。</p>
</li>
</ol>
<p><strong>构建和运行</strong></p>
<ol>
<li><p><strong>选择目标</strong></p>
<p>在Xcode顶部的工具栏中，您可以选择要在哪个模拟器或真实设备上运行您的应用。</p>
</li>
<li><p><strong>构建并运行应用</strong></p>
<p>点击工具栏中的“Run”按钮（或使用快捷键<code>Command + R</code>）来构建并运行您的应用。如果一切设置正确，您应该能看到您的SwiftUI应用在模拟器或设备上运行。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>设置Xcode并开始使用SwiftUI是开发现代iOS应用的第一步。通过Xcode，您可以使用SwiftUI框架来创建美观、响应迅速且易于维护的用户界面。本节提供了有关如何安装和配置Xcode、创建新的SwiftUI项目以及构建和运行应用的基本信息。掌握这些基础知识后，您将准备好深入探索SwiftUI的强大功能，并开始构建您自己的应用。</p>
<p><strong>2. Swift Package Manager</strong></p>
<p>Swift Package Manager（简称SPM）是Apple官方提供的一个用于自动化Swift代码的依赖管理和分发的工具。它与Xcode紧密集成，允许开发者方便地添加、更新和管理依赖库。</p>
<p><strong>SPM的概念</strong></p>
<ol>
<li><strong>包（Package）</strong>：是一个或多个库的集合，它们共享一个构建设置和版本号。</li>
<li><strong>库（Library）</strong>：是可复用代码的集合，用于构建程序或其他库。</li>
<li><strong>依赖（Dependency）</strong>：是您的项目需要的外部库或包。</li>
</ol>
<p><strong>使用Swift Package Manager</strong></p>
<ol>
<li><p><strong>创建Package.swift</strong></p>
<p>为了使用SPM，您的项目需要一个<code>Package.swift</code>文件，这是一个定义了包的名称、平台、Swift版本和依赖的清单文件。以下是一个基本的<code>Package.swift</code>示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version:5.3</span></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package <span class="operator">=</span> <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">&quot;MyLibrary&quot;</span>,</span><br><span class="line">    platforms: [</span><br><span class="line">       .macOS(.v10_15), .iOS(.v13)</span><br><span class="line">    ],</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">&quot;MyLibrary&quot;</span>,</span><br><span class="line">            targets: [<span class="string">&quot;MyLibrary&quot;</span>]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: <span class="string">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class="string">&quot;1.0.0&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">&quot;MyLibrary&quot;</span>,</span><br><span class="line">            dependencies: []),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: <span class="string">&quot;MyLibraryTests&quot;</span>,</span><br><span class="line">            dependencies: [<span class="string">&quot;MyLibrary&quot;</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加依赖</strong></p>
<p>在<code>Package.swift</code>文件中，您可以添加其他包作为依赖。SPM将自动下载和链接这些依赖。</p>
</li>
<li><p><strong>集成到Xcode项目</strong></p>
<p>您可以通过Xcode直接添加SPM依赖：</p>
<ul>
<li>打开Xcode项目或工作区。</li>
<li>选择“File” &gt; “Swift Packages” &gt; “Add Package Dependency…”。</li>
<li>输入包的Git存储库URL，然后选择一个版本号或分支。</li>
<li>选择要添加到哪个目标，然后完成集成流程。</li>
</ul>
</li>
<li><p><strong>使用命令行</strong></p>
<p>您也可以通过命令行界面使用SPM：</p>
<ul>
<li><code>swift build</code>：构建您的项目。</li>
<li><code>swift test</code>：测试您的项目。</li>
<li><code>swift run</code>：运行您的项目。</li>
<li><code>swift package update</code>：更新您的依赖。</li>
</ul>
</li>
</ol>
<p><strong>管理依赖版本</strong></p>
<p>SPM支持多种方式指定依赖版本：</p>
<ul>
<li>指定一个具体版本号。</li>
<li>指定一个版本范围。</li>
<li>使用分支名称或提交哈希。</li>
</ul>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.package(url: <span class="string">&quot;https://github.com/someone/Something.git&quot;</span>, .exact(<span class="string">&quot;1.0.0&quot;</span>))</span><br><span class="line">.package(url: <span class="string">&quot;https://github.com/someone/Something.git&quot;</span>, from: <span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">.package(url: <span class="string">&quot;https://github.com/someone/Something.git&quot;</span>, .branch(<span class="string">&quot;main&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>Swift Package Manager是一个强大的依赖管理工具，它简化了Swift项目中库和依赖的管理。通过声明式的<code>Package.swift</code>文件和Xcode的集成，SPM使得添加、更新和维护依赖变得既简单又可靠。了解SPM是现代Swift开发的重要组成部分，尤其是当您开始构建更大型且依赖多个第三方库的项目时。掌握SPM的使用将帮助您保持项目的清洁和组织，提高构建的可复用性和可维护性。</p>
<p><strong>3. 创建第一个SwiftUI应用</strong></p>
<p>进入到SwiftUI世界的第一步是创建您的第一个SwiftUI应用。本节将指导您完成创建和运行一个基本的SwiftUI应用程序的步骤，让您快速体验到SwiftUI开发的流畅和直观。</p>
<p><strong>设置项目</strong></p>
<ol>
<li><p><strong>启动Xcode</strong>：<br>打开Xcode。在欢迎屏幕上选择“Create a new Xcode project”或在菜单栏选择“File” &gt; “New” &gt; “Project”。</p>
</li>
<li><p><strong>选择模板</strong>：<br>在项目模板选择界面，选择“App”作为项目模板。这将创建一个包含所有必需文件的iOS应用程序项目。</p>
</li>
<li><p><strong>项目配置</strong>：<br>在“Choose options for your new project”界面，填写项目的详细信息：</p>
<ul>
<li><code>Product Name</code>：应用程序的名称。</li>
<li><code>Team</code>：如果您已注册Apple开发者计划并设置了Xcode，选择您的开发者团队。</li>
<li><code>Organization Identifier</code>：通常是您或您公司的域名反写（例如com.example）。</li>
<li><code>Interface</code>：确保选择“SwiftUI”。</li>
<li><code>Language</code>：选择“Swift”。</li>
<li><code>Lifecycle</code>：根据您的需求选择“SwiftUI App”。</li>
<li><code>Use Core Data</code>：如果不需要，保持未选中状态。</li>
<li><code>Include Tests</code>：如果您打算写测试，选择相应的测试复选框。</li>
</ul>
</li>
<li><p><strong>选择保存位置</strong>：<br>选择一个适合您项目的位置，并且如果您想使用版本控制（例如Git），确保选中“Create Git repository”。</p>
</li>
</ol>
<p><strong>探索SwiftUI工作区</strong></p>
<ol>
<li><p><strong>Project Navigator</strong>：<br>在Xcode左侧的侧边栏中，您可以看到Project Navigator，它展示了项目中所有的文件和资源。</p>
</li>
<li><p><strong>ContentView.swift</strong>：<br>这是您的SwiftUI视图代码所在的文件。Xcode默认为您提供了一个包含Text视图的简单SwiftUI视图。</p>
</li>
<li><p><strong>Preview</strong>：<br>Xcode支持SwiftUI的实时预览。如果Preview未自动显示，您可以点击代码编辑器顶部的“Resume”按钮来加载它。</p>
</li>
</ol>
<p><strong>编写SwiftUI代码</strong></p>
<ol>
<li><p><strong>修改ContentView</strong>：</p>
<ul>
<li><p>用以下代码替换<code>ContentView</code>结构体中的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, SwiftUI!&quot;</span>)</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用Preview</strong>：</p>
<ul>
<li>使用Preview功能，您可以实时看到代码更改的效果。如果预览未显示，点击“Resume”按钮。</li>
</ul>
</li>
</ol>
<p><strong>运行应用</strong></p>
<ol>
<li><p><strong>选择模拟器或设备</strong>：<br>在Xcode工具栏中，选择一个模拟器或连接的设备作为目标。</p>
</li>
<li><p><strong>构建并运行</strong>：<br>点击工具栏中的“Run”按钮或使用快捷键<code>Command + R</code>来编译并运行您的应用。</p>
</li>
<li><p><strong>查看结果</strong>：<br>您的应用程序将启动，并在所选模拟器或设备上显示“Hello, SwiftUI!”文本。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>恭喜您！通过完成这些步骤，您已经成功创建并运行了您的第一个SwiftUI应用。这只是一个开始，SwiftUI有着非常丰富的视图和控件供您使用，通过学习和实验，您将能够构建出功能强大且界面美观的应用程序。接下来的章节中，我们将进一步深入探索SwiftUI提供的各种构建用户界面的工具和技术。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/08/SwiftUI%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC3%E7%AB%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="cltv9a4xv002cgo74hjmk4rkt" data-title="SwiftUI核心技术第3章环境搭建" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SwiftUI/">SwiftUI</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BufferedReader/" rel="tag">BufferedReader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InputStreamReader/" rel="tag">InputStreamReader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PrintWriter/" rel="tag">PrintWriter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ServerSocket/" rel="tag">ServerSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socket/" rel="tag">Socket</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BufferedReader/" style="font-size: 10px;">BufferedReader</a> <a href="/tags/InputStreamReader/" style="font-size: 10px;">InputStreamReader</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/PrintWriter/" style="font-size: 10px;">PrintWriter</a> <a href="/tags/ServerSocket/" style="font-size: 20px;">ServerSocket</a> <a href="/tags/Socket/" style="font-size: 20px;">Socket</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/19/SwiftUI%E4%B8%AD%E7%9A%84scrollTransition%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">SwiftUI中的scrollTransition修饰符怎么使用？</a>
          </li>
        
          <li>
            <a href="/2024/03/17/%E4%BD%BF%E7%94%A8JavaNIO%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAHelloWorld%E7%A8%8B%E5%BA%8F/">使用JavaNIO编写一个HelloWorld程序</a>
          </li>
        
          <li>
            <a href="/2024/03/14/Docker%E9%83%A8%E7%BD%B2xxl-job-admin%E6%AD%A5%E9%AA%A4/">用 Docker 部署 xxl-job 简明指南</a>
          </li>
        
          <li>
            <a href="/2023/11/12/%E5%9C%A8Mac%E4%B8%8A%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%89%80%E5%9C%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F/">在Mac上如何终止某个端口所在的进程？</a>
          </li>
        
          <li>
            <a href="/2023/11/09/Java%E5%AE%9E%E7%8E%B0%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%80%9A%E4%BF%A1/">Java实现两台计算机之间长连接通信</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>